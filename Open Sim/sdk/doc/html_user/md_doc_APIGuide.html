<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>API: API Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen_user.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenSimLogoWhiteHorizontal_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">API
   &#160;<span id="projectnumber">4.1</span>
   </div>
   <div id="projectbrief">For MATLAB, Python, Java, and C++ users</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Class&#160;Groups</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('md_doc_APIGuide.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">API Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#intendedaudience">Intended Audience</a></li>
<li class="level1"><a href="#overviewoftheapi">Overview of the OpenSim API for Developers</a><ul><li class="level2"><a href="#opensimpurpose">OpenSim’s Purpose</a></li>
<li class="level2"><a href="#designphilosophy">Design Philosophy</a></li>
<li class="level2"><a href="#organization">Organization of OpenSim</a></li>
<li class="level2"><a href="#simpleexample">A Simple Example</a></li>
<li class="level2"><a href="#systemstate">System and State</a></li>
<li class="level2"><a href="#object">Object</a></li>
<li class="level2"><a href="#component">Component</a><ul><li class="level3"><a href="#modelscomposed">Models are composed of Components</a></li>
<li class="level3"><a href="#property">Property</a></li>
<li class="level3"><a href="#socket">Socket</a></li>
<li class="level3"><a href="#inputsoutputs">Inputs and Outputs</a></li>
<li class="level3"><a href="#operator">Operator</a></li>
<li class="level3"><a href="#source">Source</a></li>
<li class="level3"><a href="#reporter">Reporter</a></li>
<li class="level3"><a href="#modelcomponent">ModelComponent</a></li>
</ul>
</li>
<li class="level2"><a href="#modelcomponents">Principal ModelComponents</a><ul><li class="level3"><a href="#frames">Frames</a></li>
<li class="level3"><a href="#points">Points, Stations and Markers</a></li>
<li class="level3"><a href="#joints">Joints</a></li>
<li class="level3"><a href="#constraints">Constraints</a></li>
<li class="level3"><a href="#forces">Forces</a></li>
<li class="level3"><a href="#actuators">Actuators</a></li>
<li class="level3"><a href="#controller">Controllers</a></li>
</ul>
</li>
<li class="level2"><a href="#datahandling">Data Handling Classes</a></li>
<li class="level2"><a href="#solvers">Solvers</a></li>
</ul>
</li>
<li class="level1"><a href="#writingcomponents">Writing your own Component</a><ul><li class="level2"><a href="#constructproperties">I. Constructing your Component’s Attributes</a></li>
<li class="level2"><a href="#finalizefromproperties">II. Finalize Properties and Connections of the Component</a></li>
<li class="level2"><a href="#addtosystem">III. Adding your Component’s Dynamics to the System</a></li>
<li class="level2"><a href="#initstatefromproperties">IV. Initializing and Recalling the State</a></li>
<li class="level2"><a href="#testComponents">Test Components</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="intendedaudience"></a>
Intended Audience</h1>
<p>This guide is recommended for those who desire in-depth knowledge of musculoskeletal modeling and simulation with OpenSim and wish to use the Application Programming Interface (API) to create or contribute novel models or algorithms not currently supported by the <a class="el" href="namespaceOpenSim.html">OpenSim</a> application. The guide also expects that you are familiar with multibody dynamics and biomechanics.</p>
<p>The <a class="el" href="namespaceOpenSim.html">OpenSim</a> software has a variety of interfaces: GUI, command line, XML, Python scripting, MATLAB scripting, and C++. This guide is designed for developers using the last 3 of these interfaces. Programming experience in C++ will be helpful in understanding the API architecture, but we have tried to make this guide accessible to those with only Matlab or Python experience, as well.</p>
<h1><a class="anchor" id="overviewoftheapi"></a>
Overview of the OpenSim API for Developers</h1>
<h2><a class="anchor" id="opensimpurpose"></a>
OpenSim’s Purpose</h2>
<p>The purpose of <a class="el" href="namespaceOpenSim.html">OpenSim</a> is to provide anyone interested in human or animal movement with high-performance software to create computer models of the neuromusculoskeletal system, analyze experimental movement data, and simulate movement dynamics to gain insights about the anatomy, physiology, mechanics and control of movement. The software is used in a variety of applications, including neuroscience research, biomechanical analysis, surgical design, and ergonomic analysis, and bioengineering education, just to name a few. Our goal is to provide physically accurate models and tools that provide a solid foundation for scientific inquiry.</p>
<p>The <a class="el" href="namespaceOpenSim.html">OpenSim</a> Application Programming Interface (<a class="el" href="namespaceOpenSim.html">OpenSim</a> API) serves the <a class="el" href="namespaceOpenSim.html">OpenSim</a> application, with its graphical user interface (GUI), and also enables advanced users and developers to write their own programs to extend the capabilities of <a class="el" href="namespaceOpenSim.html">OpenSim</a>, including customized analyses and workflows, Components, and <a class="el" href="namespaceOpenSim.html">OpenSim</a> plug-ins.</p>
<h2><a class="anchor" id="designphilosophy"></a>
Design Philosophy</h2>
<p>The ethos of the <a class="el" href="namespaceOpenSim.html">OpenSim</a> API is that the code is modular, reusable, and easily extensible. To enable the assembly of neuromusculoskeletal systems from constituent biomechanical elements, <a class="el" href="namespaceOpenSim.html">OpenSim</a> has adopted the <a href="https://en.wikipedia.org/wiki/Composite_pattern">composite design pattern</a> to systematically define, organize, and manage the elements (components) of a neuromusculoskeletal system.</p>
<h2><a class="anchor" id="organization"></a>
Organization of OpenSim</h2>
<p><a class="el" href="namespaceOpenSim.html">OpenSim</a> is built on <a class="el" href="namespaceSimTK.html">SimTK</a> computational and simulation libraries that provide low-level, efficient math and matrix algebra libraries, such as LAPACK, as well as the infrastructure for defining a dynamic System and its State. One can think of the System as the set of differential equations, and the state as its variables.</p>
<p>Empowering the computational layer is Simbody, an efficient multibody dynamics solver, which provides an extensible multibody System and State. The <a class="el" href="namespaceOpenSim.html">OpenSim</a> modeling layer maps biomechanical structures (bones, muscles, tendons, etc.) into bodies and forces so that the dynamics of the System can be computed by Simbody. The Simbody Users Guide can be found <a href="https://github.com/simbody/simbody/raw/master/Simbody/doc/SimbodyAndMolmodelUserGuide.pdf">here</a> and can help new users to understand the structure of <a class="el" href="namespaceOpenSim.html">OpenSim</a>.</p>
<h3>The Three Interface Layers of <a class="el" href="namespaceOpenSim.html">OpenSim</a> Built on <a class="el" href="namespaceSimTK.html">SimTK</a></h3>
<div class="image">
<img src="./images/InterfaceLayers.png"  alt="Interface Layers" height="328.5" width="681"/>
</div>
<p><a class="el" href="namespaceOpenSim.html">OpenSim</a> (opensim-core) is essentially a set of libraries for building simple to complex musculoskeletal systems with complex actuators (e.g., muscles) and other forces (e.g., foot-ground contact), and enabling the motion (kinematics) of highly articulated bodies (bones). Torque, linear and physiological actuators such as muscles can be controlled by model controllers (e.g., Computed Muscle Control) to estimate the neural control and muscle forces required to reproduce human movement. An analysis layer is equipped with solvers and optimization algorithms for performing calculations with the model and to report results. At the highest level, these blocks are assembled into specialized applications (e.g., the <code>opensim-cmd</code> command-line application) to simulate and analyze model movement and internal dynamics. The <a class="el" href="namespaceOpenSim.html">OpenSim</a> application is a Java-based program that calls Tools, Models, and underlying computations in <a class="el" href="namespaceSimTK.html">SimTK</a> via an interactive graphical user interface (GUI).</p>
<h3>A Composite Model Framework for Building a Computational System</h3>
<p>In <a class="el" href="namespaceOpenSim.html">OpenSim</a>, a Component is a computational model element that describes some physical phenomenon. As a neuromusculoskeletal simulator, <a class="el" href="namespaceOpenSim.html">OpenSim</a> components represent bodies, joints, muscles, and other physical structures, as well as sensors, controllers, and feedback circuits that describe human and animal dynamics. The purpose of a Component is to both capture the physical phenomenon (degrees-of-freedom, constraints, actuation, control) of interest and to enable the systematic composition of complex behaviors (dynamical models) from simpler components.</p>
<p>To illustrate this point, think of two biomechanists, Gary Gait and Norma Knee. Gary is interested in the actions of individual muscles during gait and other forms of locomotion. Norma wants to understand how loads are distributed within the knee and their effect on cartilage wear and health. For Gary, a model represents a patient’s musculoskeletal dynamics and is capable of muscle-driven gait that reproduces human-like performance. In Norma’s case, a model consists of a femur, a tibia, a patella, contact between articulating surfaces, ligaments, and muscles, so that she can compute contact forces. Gary and Norma’s "models" may have similar complexity but their concepts of a model are fundamentally different (i.e., whole body vs. a knee). Gary may model knees as pin joints and attain reasonable answers about the action of leg muscles during different types of gait. Norma cannot justify the same simplification. A more accurate knee model may result in more realistic muscle forces for Gary, and simulated muscle forces (that reproduce human gait) may provide better boundary conditions for Norma’s estimates of knee loads. However, for these researchers to benefit directly from each other’s work, their models must be interoperable. In order for their models to talk to one another and be systematically combined, both models must have constructs in common. This modularity and interoperability is the main purpose of the Component API.</p>
<div class="image">
<img src="./images/OverviewFigure1_new.jpg"  alt="Figure 1" height="500" width="750"/>
</div>
<p><em>Figure 1. Overview of the <a class="el" href="namespaceOpenSim.html">OpenSim</a> Modeling Framework. Aspects of the musculoskeletal system (Physical System) such as bones, joints, and muscles, and its neurocontrol composed of spinal circuits, muscle spindle and Golgi tendon organs are represented as Components in the Modeling Framework. The specification of the types and arrangement of Components in a Model reflect the physical system being modeled and is the main task of the Modeler. From the assembly of Components (the Model) the corresponding computational System (system of equations readily solved by a computer) is automatically created and ready for numerical simulation and analysis. All System unknowns (variables) and their values are in the State.</em></p>
<h2><a class="anchor" id="simpleexample"></a>
A Simple Example</h2>
<p>To get a taste of what the <a class="el" href="namespaceOpenSim.html">OpenSim</a> API looks like, here is a complete example of building and simulating a simple arm whose elbow is actuated by a muscle (this example is in C++; you can find a Python version at <code>Bindings/Python/examples/build_simple_arm_model.py</code>):</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;OpenSim/OpenSim.h&gt;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceSimTK.html">SimTK</a>;</div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceOpenSim.html">OpenSim</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main() {</div><div class="line">    <a class="code" href="classOpenSim_1_1Model.html">Model</a> model;</div><div class="line">    model.<a class="code" href="classOpenSim_1_1Object.html#a44921f417260a606255a162bfaa74e85">setName</a>(<span class="stringliteral">&quot;bicep_curl&quot;</span>);</div><div class="line"><span class="preprocessor">#ifdef VISUALIZE</span></div><div class="line">    model.<a class="code" href="classOpenSim_1_1Model.html#a308667195f47b0cec7f8aabd8e93af85">setUseVisualizer</a>(<span class="keyword">true</span>);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">// Create two links, each with a mass of 1 kg, center of mass at the body&#39;s</span></div><div class="line">    <span class="comment">// origin, and moments and products of inertia of zero.</span></div><div class="line">    <a class="code" href="classOpenSim_1_1Body.html">OpenSim::Body</a>* humerus = <span class="keyword">new</span> <a class="code" href="classOpenSim_1_1Body.html">OpenSim::Body</a>(<span class="stringliteral">&quot;humerus&quot;</span>, 1, Vec3(0), Inertia(0));</div><div class="line">    <a class="code" href="classOpenSim_1_1Body.html">OpenSim::Body</a>* radius  = <span class="keyword">new</span> <a class="code" href="classOpenSim_1_1Body.html">OpenSim::Body</a>(<span class="stringliteral">&quot;radius&quot;</span>,  1, Vec3(0), Inertia(0));</div><div class="line"></div><div class="line">    <span class="comment">// Connect the bodies with pin joints. Assume each body is 1 m long.</span></div><div class="line">    <a class="code" href="classOpenSim_1_1PinJoint.html">PinJoint</a>* shoulder = <span class="keyword">new</span> <a class="code" href="classOpenSim_1_1PinJoint.html">PinJoint</a>(<span class="stringliteral">&quot;shoulder&quot;</span>,</div><div class="line">            <span class="comment">// Parent body, location in parent, orientation in parent.</span></div><div class="line">            model.<a class="code" href="classOpenSim_1_1Model.html#a7f45ceda5cdb1252f94fd95705770b77">getGround</a>(), Vec3(0), Vec3(0),</div><div class="line">            <span class="comment">// Child body, location in child, orientation in child.</span></div><div class="line">            *humerus, Vec3(0, 1, 0), Vec3(0));</div><div class="line">    <a class="code" href="classOpenSim_1_1PinJoint.html">PinJoint</a>* elbow = <span class="keyword">new</span> <a class="code" href="classOpenSim_1_1PinJoint.html">PinJoint</a>(<span class="stringliteral">&quot;elbow&quot;</span>,</div><div class="line">            *humerus, Vec3(0), Vec3(0), *radius, Vec3(0, 1, 0), Vec3(0));</div><div class="line"></div><div class="line">    <span class="comment">// Add a muscle that flexes the elbow.</span></div><div class="line">    <a class="code" href="classOpenSim_1_1Millard2012EquilibriumMuscle.html">Millard2012EquilibriumMuscle</a>* biceps = <span class="keyword">new</span></div><div class="line">        <a class="code" href="classOpenSim_1_1Millard2012EquilibriumMuscle.html">Millard2012EquilibriumMuscle</a>(<span class="stringliteral">&quot;biceps&quot;</span>, 200, 0.6, 0.55, 0);</div><div class="line">    biceps-&gt;<a class="code" href="classOpenSim_1_1PathActuator.html#ae4e799345b9406338b79321d5f10ceda">addNewPathPoint</a>(<span class="stringliteral">&quot;origin&quot;</span>,    *humerus, Vec3(0, 0.8, 0));</div><div class="line">    biceps-&gt;<a class="code" href="classOpenSim_1_1PathActuator.html#ae4e799345b9406338b79321d5f10ceda">addNewPathPoint</a>(<span class="stringliteral">&quot;insertion&quot;</span>, *radius,  Vec3(0, 0.7, 0));</div><div class="line"></div><div class="line">    <span class="comment">// Add a controller that specifies the excitation of the muscle.</span></div><div class="line">    <a class="code" href="classOpenSim_1_1PrescribedController.html">PrescribedController</a>* brain = <span class="keyword">new</span> <a class="code" href="classOpenSim_1_1PrescribedController.html">PrescribedController</a>();</div><div class="line">    brain-&gt;<a class="code" href="classOpenSim_1_1Controller.html#a574b6946ed86012686f257202ebae1d4">addActuator</a>(*biceps);</div><div class="line">    <span class="comment">// Muscle excitation is 0.3 for the first 0.5 seconds, then increases to 1.</span></div><div class="line">    brain-&gt;<a class="code" href="classOpenSim_1_1PrescribedController.html#aac9f7276579febf1cb1d29875cb134d0">prescribeControlForActuator</a>(<span class="stringliteral">&quot;biceps&quot;</span>,</div><div class="line">            <span class="keyword">new</span> <a class="code" href="classOpenSim_1_1StepFunction.html">StepFunction</a>(0.5, 3, 0.3, 1));</div><div class="line"></div><div class="line">    <span class="comment">// Add components to the model.</span></div><div class="line">    model.<a class="code" href="classOpenSim_1_1Model.html#a65fb0b107cdfd1ab9bdd48db5aca5777">addBody</a>(humerus);    model.<a class="code" href="classOpenSim_1_1Model.html#a65fb0b107cdfd1ab9bdd48db5aca5777">addBody</a>(radius);</div><div class="line">    model.<a class="code" href="classOpenSim_1_1Model.html#a17cf3731e842a6951269e011cfc64161">addJoint</a>(shoulder);  model.<a class="code" href="classOpenSim_1_1Model.html#a17cf3731e842a6951269e011cfc64161">addJoint</a>(elbow);</div><div class="line">    model.<a class="code" href="classOpenSim_1_1Model.html#ab257fb0a1fb3a52e412beb48d6c9b8be">addForce</a>(biceps);</div><div class="line">    model.<a class="code" href="classOpenSim_1_1Model.html#a5a8d8e0a2c83e7b228863608e877a2bf">addController</a>(brain);</div><div class="line"></div><div class="line">    <span class="comment">// Add a console reporter to print the muscle fiber force and elbow angle.</span></div><div class="line">    ConsoleReporter* reporter = <span class="keyword">new</span> ConsoleReporter();</div><div class="line">    reporter-&gt;set_report_time_interval(1.0);</div><div class="line">    reporter-&gt;addToReport(biceps-&gt;<a class="code" href="classOpenSim_1_1Component.html#a0ee8629c6af627c205a2b3810c4e430c">getOutput</a>(<span class="stringliteral">&quot;fiber_force&quot;</span>));</div><div class="line">    reporter-&gt;addToReport(</div><div class="line">        elbow-&gt;getCoordinate(PinJoint::Coord::RotationZ).getOutput(<span class="stringliteral">&quot;value&quot;</span>),</div><div class="line">        <span class="stringliteral">&quot;elbow_angle&quot;</span>);</div><div class="line">    model.<a class="code" href="classOpenSim_1_1Component.html#a221d0efee5be29cd21b37d9a51e3dbe1">addComponent</a>(reporter);</div><div class="line"></div><div class="line">    <span class="comment">// Add display geometry.</span></div><div class="line">    <a class="code" href="classOpenSim_1_1Ellipsoid.html">Ellipsoid</a> bodyGeometry(0.1, 0.5, 0.1);</div><div class="line">    bodyGeometry.setColor(Gray);</div><div class="line">    <span class="comment">// Attach an ellipsoid to a frame located at the center of each body.</span></div><div class="line">    <a class="code" href="classOpenSim_1_1PhysicalOffsetFrame.html">PhysicalOffsetFrame</a>* humerusCenter = <span class="keyword">new</span> <a class="code" href="classOpenSim_1_1PhysicalOffsetFrame.html">PhysicalOffsetFrame</a>(</div><div class="line">        <span class="stringliteral">&quot;humerusCenter&quot;</span>, *humerus, Transform(Vec3(0, 0.5, 0)));</div><div class="line">    humerus-&gt;<a class="code" href="classOpenSim_1_1Component.html#a221d0efee5be29cd21b37d9a51e3dbe1">addComponent</a>(humerusCenter);</div><div class="line">    humerusCenter-&gt;<a class="code" href="classOpenSim_1_1Frame.html#a0ac9ab826ccb61cca72dec2daa981395">attachGeometry</a>(bodyGeometry.clone());</div><div class="line">    <a class="code" href="classOpenSim_1_1PhysicalOffsetFrame.html">PhysicalOffsetFrame</a>* radiusCenter = <span class="keyword">new</span> <a class="code" href="classOpenSim_1_1PhysicalOffsetFrame.html">PhysicalOffsetFrame</a>(</div><div class="line">        <span class="stringliteral">&quot;radiusCenter&quot;</span>, *radius, Transform(Vec3(0, 0.5, 0)));</div><div class="line">    radius-&gt;<a class="code" href="classOpenSim_1_1Component.html#a221d0efee5be29cd21b37d9a51e3dbe1">addComponent</a>(radiusCenter);</div><div class="line">    radiusCenter-&gt;<a class="code" href="classOpenSim_1_1Frame.html#a0ac9ab826ccb61cca72dec2daa981395">attachGeometry</a>(bodyGeometry.clone());</div><div class="line"></div><div class="line">    <span class="comment">// Configure the model.</span></div><div class="line">    State&amp; state = model.<a class="code" href="classOpenSim_1_1Model.html#aaa4bbbfcb5ea9de9f2605eb6b0e886e5">initSystem</a>();</div><div class="line">    <span class="comment">// Fix the shoulder at its default angle and begin with the elbow flexed.</span></div><div class="line">    shoulder-&gt;<a class="code" href="classOpenSim_1_1PinJoint.html#aa9c962e80471fe99e61c9fae6ac24462">getCoordinate</a>().<a class="code" href="classOpenSim_1_1Coordinate.html#a4a5b61ac8fc198a4d2fcfa196c4b7fbc">setLocked</a>(state, <span class="keyword">true</span>);</div><div class="line">    elbow-&gt;getCoordinate().setValue(state, 0.5 * Pi);</div><div class="line">    model.<a class="code" href="classOpenSim_1_1Model.html#a4fa0514603ddd6793030f5f198908b77">equilibrateMuscles</a>(state);</div><div class="line"></div><div class="line">    <span class="comment">// Configure the visualizer.</span></div><div class="line"><span class="preprocessor">#ifdef VISUALIZE</span></div><div class="line">    model.<a class="code" href="classOpenSim_1_1Model.html#aa3bccb5364a2521101626f71b5b2233b">updMatterSubsystem</a>().setShowDefaultGeometry(<span class="keyword">true</span>);</div><div class="line">    Visualizer&amp; viz = model.<a class="code" href="classOpenSim_1_1Model.html#a9f72cc7f29162f376a412811c2c4e83b">updVisualizer</a>().<a class="code" href="classOpenSim_1_1ModelVisualizer.html#a47fdcb67e86d73dc6598a9d49c436a70">updSimbodyVisualizer</a>();</div><div class="line">    viz.setBackgroundType(viz.SolidColor);</div><div class="line">    viz.setBackgroundColor(White);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="comment">// Simulate.</span></div><div class="line">    <a class="code" href="namespaceOpenSim.html#a5821a4ca8e6fe9b0cb2b5492665b5dc0">simulate</a>(model, state, 10.0);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">};</div></div><!-- fragment --><p> This code produces the following animation:</p>
<div class="image">
<img src="./images/opensim_double_pendulum_muscle.gif"  alt="Simple Arm Model" height="512" width="512"/>
</div>
<p><em>Simple Arm Model. A two-body pendulum with single muscle actuator.</em></p>
<p>and prints the following information to the console: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;[reporter]</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;              |   /model_/bice|               |</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;          time| ps|fiber_force|    elbow_angle|</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;--------------| --------------| --------------|</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  0.000000e+00| 1.18096897e+00| 1.57079633e+00|</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;1.00000000e+00| 5.72750904e+01| 7.70664118e-01|</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;2.00000000e+00| 1.97284113e+01| 1.56804557e+00|</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;3.00000000e+00| 5.60904315e+01| 1.44198608e+00|</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;4.00000000e+00| 3.45483498e+01| 1.50834805e+00|</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;5.00000000e+00| 3.26037208e+01| 1.51802366e+00|</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;6.00000000e+00| 3.71360518e+01| 1.50212351e+00|</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;7.00000000e+00| 3.56985024e+01| 1.50718884e+00|</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;8.00000000e+00| 3.41860103e+01| 1.50791862e+00|</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;9.00000000e+00| 3.43416494e+01| 1.50672695e+00|</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;1.00000000e+01| 3.57847134e+01| 1.50716396e+00|</div></div><!-- fragment --><h2><a class="anchor" id="systemstate"></a>
System and State</h2>
<p>A SimTK::System is the computational (mathematical) system of equations that represents the model dynamics, in a way that a computer can solve. In <a class="el" href="namespaceOpenSim.html">OpenSim</a>, the model is formed by rigid bodies (e.g. bones) and connected by joints. A State is a set of values for all the unknowns (variables) of the System’s equations. The State contains all values necessary to fully evaluate the system of equations. The SimTK::State includes time and the generalized coordinates (Q; the joint angles and displacements) and the generalized speeds (U) of the multibody system. Any Component can add to the System (and State). For example, Muscles add their activation and fiber length variables to the State with their corresponding differential equations in the System. An <a class="el" href="namespaceOpenSim.html">OpenSim</a> Model generates a System in order to perform calculations and solve for unknowns of interest to the modeler.</p>
<div class="image">
<img src="./images/system_and_state.png"  alt="Figure 2" height="256" width="731"/>
</div>
<p><em>Figure 2. An illustration of the difference between the model's System and a State object. Static model parameters (gravity, mass, inertia, muscle-tendon properties, etc.) are accessible directly via the Model, while methods that return state-dependent values (mass center position, muscle fiber velocity, etc.) require a State object argument.</em></p>
<p>A <a class="el" href="classOpenSim_1_1StatesTrajectory.html">StatesTrajectory</a> is a sequence of States that satisfy the dynamical system of equations through time.</p>
<div class="fragment"><div class="line"><span class="comment">// Generate the System and State that implements the model (Namespace specification e.g. &#39;SimTK::&#39; is needed only in C++)</span></div><div class="line">SimTK::State state = model.<a class="code" href="classOpenSim_1_1Model.html#aaa4bbbfcb5ea9de9f2605eb6b0e886e5">initSystem</a>();</div><div class="line"><span class="keywordtype">int</span> nq = state.getNQ();               <span class="comment">// Number of generalized coordinates</span></div><div class="line">SimTK::Vector q = state.getQ();       <span class="comment">// Values of generalized coordinates</span></div><div class="line">SimTK::Vector qdot = state.getQDot(); <span class="comment">// Derivatives of generalized coordinates.</span></div></div><!-- fragment --><p>Any method in <a class="el" href="namespaceOpenSim.html">OpenSim</a> that performs a calculation that doesn’t simply depend on constants takes a SimTK::State object as the first argument. </p><div class="fragment"><div class="line">model.getMassCenter(state); <span class="comment">// Need to know pose of model.</span></div></div><!-- fragment --><h2><a class="anchor" id="object"></a>
Object</h2>
<p><a class="el" href="classOpenSim_1_1Object.html">Object</a> is the base class for all <a class="el" href="namespaceOpenSim.html">OpenSim</a> Components, general containers like Set, and Tools that require serialization - that is having their attributes written out to file. Objects use Properties to serialize (write to file) and deserialize (read from file) their attributes, which are parameters and settings that define the behavior of the Object.</p>
<h2><a class="anchor" id="component"></a>
Component</h2>
<p>A <a class="el" href="classOpenSim_1_1Component.html">Component</a> is the basic "unit" of modelling and computing in <a class="el" href="namespaceOpenSim.html">OpenSim</a>. It is our abstraction to capture a fundamental unit of computing and/or modeling used to compose a Model and form its computational system of equations. It is the base class that provides the supporting infrastructure for building up a hierarchically structured model with interconnections and numerous inputs and outputs, but is represented by a single computationally efficient (mathematical/numerical) system. That computational system is a SimTK::MultibodySystem and it is the computer implementation (think system of equations) of the multibody kinematics and dynamics plus any additional dynamics (ordinary differential equations, e.g. muscle activation dynamics) that need to be solved simultaneously. Any conceptual element that has to compute something typically requires the System and must be a Component in <a class="el" href="namespaceOpenSim.html">OpenSim</a>. Component also provides the resources for reading and writing (also known as serializing, which it inherits from Object) the attributes/parameters that define the behavior of the component and adding in its dynamics (equations). The serializable attributes of a Component are called properties in <a class="el" href="namespaceOpenSim.html">OpenSim</a>. </p><div class="image">
<img src="./images/component.png"  alt="Figure 3" height="381.5" width="415"/>
</div>
<p><em>Figure 3. Illustration of a generic component object, with property, input, output, and socket attributes.</em></p>
<p>A Component has the following defining attributes:</p><ol type="1">
<li>Properties: constant (time-invariant) parameters (e.g., a Body’s mass).</li>
<li>Sockets to other components that it depends on (e.g., a Joint connects two Frames).</li>
<li>Input quantities that the component needs to do its job (e.g., a metabolics calculator component could have a "muscle power" input).</li>
<li>Output quantities that component can compute, and that can be used to satisfy other components’ Inputs.</li>
<li>Subcomponents: A Component can rely on other components to do its job (e.g., a Muscle component can use subcomponents for activation and fiber-contraction dynamics). These are not user facing and are of interest only to the component writer.</li>
</ol>
<p>The common task for a Component (as part of a Model) is to make its contribution to the System (e.g. when Model::initSystem() if called). When the underlying System is built all the variables in the system equations appear in the State. As a unit of computation, the Component has the following computational attributes:</p>
<ol type="1">
<li>Continuous state variables (usually referred to as "state variables") are the variables in the dynamical equations contributed by the Component (e.g. activation and fiber-length state variables of a Muscle)</li>
<li>Discrete state variables are system unknowns that may or may not be governed by differential or algebraic equations, and include external inputs and controls. For example, when the actuation (force or tension that an actuator produces) of an Actuator is overridden, the override-actuation is a discrete state variable and must be supplied.</li>
<li>Cache variables allow saving of (state-dependent) calculations that may be used multiple times, to improve computational efficiency. For example, computing the path length of a muscle with several intermediate points and wrapping over obstacles is expensive. Therefore, a path component itself caches its length so that the muscle (or any other component) that needs the length in its computations does not reevaluate it unnecessarily. The validity of the path length cache variable is dependent on the generalized coordinates&ndash;as long as these generalized coordinates do not change, the path length is valid. <a class="el" href="namespaceOpenSim.html">OpenSim</a> employs categories of dependency known as realization Stages (see Simbody User Guide, Section 2.4 for details) to manage the validity of cache variables. Any changes to the generalized coordinates invalidate (and wipe out) any cache variables associated with the Position Stage and all other subsequent (Velocity, Dynamics, Acceleration) stages. <a class="el" href="namespaceOpenSim.html">OpenSim</a> automatically invalidates cache variables to support the correctness of simulations. Manual cache management is highly prone to errors leading to "stale" variables and potentially incorrect physics. Sadly, while results may appear plausible they are completely invalid and sometimes impossible to detect and debug. If you need to cache for performance, use OpenSim’s facilities.</li>
</ol>
<h3><a class="anchor" id="modelscomposed"></a>
Models are composed of Components</h3>
<p>A Component encapsulates (all or part of the) system dynamics (of a model or element of a model) and provides (computes) values of interest. A component adds its dynamics and allocates necessary resources (state, cache, and other variables). It defines parameters (see Properties below) that specify its behavior/function and defines dependencies on any other Components (see Sockets below) via its Inputs and Outputs.</p>
<p>Components of a <a class="el" href="classOpenSim_1_1Model.html">Model</a> form a rooted directed tree topology of ownership (Components own and know about their subcomponents). Subcomponents of a component are the descendants in the tree. A root component (the top level Model) contains all the necessary Components to define the System. Components in the tree are uniquely identified by their full path name from the root (like a file path)</p>
<p>A branch in the ownership tree of a Model can be a complete subassembly representing a Device, a Leg or another FullBody Model.</p>
<p>This Component architecture means that:</p><ul>
<li>A Component can be composed of Components</li>
<li>A Model is a Component</li>
<li>A Model is composed of Components</li>
<li>A Model can be composed of Models</li>
</ul>
<p>You can add a subcomponent to another Component like so: </p><div class="fragment"><div class="line">CoordinateActuator* act = <span class="keyword">new</span> CoordinateActuator();</div><div class="line">act-&gt;setName(<span class="stringliteral">&quot;motor&quot;</span>);</div><div class="line">device.addComponent(act);</div></div><!-- fragment --><p>You can access existing subcomponents by name: </p><div class="fragment"><div class="line"><span class="comment">// Get as abstract Component.</span></div><div class="line">Component&amp; c = device.updComponent(<span class="stringliteral">&quot;motor&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Get as concrete Component.</span></div><div class="line"><span class="keyword">auto</span>&amp; a = device.updComponent&lt;CoordinateActuator&gt;(<span class="stringliteral">&quot;motor&quot;</span>);</div></div><!-- fragment --><p>You can also iterate through all subcomponents of a component, recursively (e.g., each subcomponent’s subcomponents): </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c : device.getComponentList()) {</div><div class="line">    c.getFullPathName();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Only iterate through Bodies</span></div><div class="line"><span class="keywordtype">double</span> totalMass = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> Body&amp; b : device.getComponentList&lt;Body&gt;()) {</div><div class="line">    totalMass = totalMass + b.getMass();</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="property"></a>
Property</h3>
<p>A Property is a fixed parameter of the model that does not change as a simulation evolves over time (i.e., is not part of or dependent on the State). A Property is a serializable (as XML) container of common data types (e.g., doubles and strings) as well as Objects (e.g., Functions) and even other Components which include properties themselves. A serialized model is the XML counterpart of the Model and its Components (as Properties).</p>
<p>For each Property, there are several methods for accessing or modifying the value of the Property. For example, a Body’s mass property has the following related methods: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> m = body.get_mass();</div><div class="line">body.set_mass(3.5);</div></div><!-- fragment --><p> The properties available in any class are listed on Doxygen, the GUI (Help &gt; XML Browser), and the command line tool (<code>opensim-cmd info Model</code>).</p>
<h3><a class="anchor" id="socket"></a>
Socket</h3>
<p>An <a class="el" href="classOpenSim_1_1Socket.html">OpenSim::Socket</a> defines the dependency of a Component on another Component (the "connectee"). The type of the connectee must be specified (e.g., Body, Joint). The dependency is specified by the connectee’s relative or absolute path name. A Socket finds and connects to the dependency when finalizeConnections() is called. The Socket provides the status of the connection (connected or not) and a reference to to the "connectee" when connected. All of a class’ Sockets are listed on the Doxygen page for that class.</p>
<p>You can query a Component for the number of Sockets it has, as well as for their names: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> numConn = joint.getNumSockets();</div><div class="line"><span class="keyword">auto</span> connNames = joint.getSocketNames();</div></div><!-- fragment --><p>You can get a reference to a specific Socket of a Component using its name: </p><div class="fragment"><div class="line">AbstractSocket&amp; parentSocket = joint.updSocket(<span class="stringliteral">&quot;parent_frame&quot;</span>);</div></div><!-- fragment --><p>Once you have a Socket, you can see what types of Components it can be connected to, and if its connection is satisfied: </p><div class="fragment"><div class="line">parentSocket.getConnecteeTypeName(); <span class="comment">// result: &quot;PhysicalOffsetFrame&quot;</span></div><div class="line"><span class="keywordtype">bool</span> satisfied = parentSocket.isConnected();</div></div><!-- fragment --><p>You can specify which Component the Socket should connect to. Here, we tell a Joint that its parent frame is Ground: </p><div class="fragment"><div class="line">parentSocket.connect(model.<a class="code" href="classOpenSim_1_1Model.html#a7f45ceda5cdb1252f94fd95705770b77">getGround</a>());</div></div><!-- fragment --><p>Alternatively, Components with Sockets provide convenience <code>connectSocket_&lt;name&gt;()</code> methods for connecting them: </p><div class="fragment"><div class="line">joint.connectSocket_parent_frame(model.<a class="code" href="classOpenSim_1_1Model.html#a7f45ceda5cdb1252f94fd95705770b77">getGround</a>());</div></div><!-- fragment --><p>To access the connectee itself, you can call the following method on the Component: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> ground = joint.getConnectee&lt;PhysicalFrame&gt;(<span class="stringliteral">&quot;parent_frame&quot;</span>);</div></div><!-- fragment --><h3><a class="anchor" id="inputsoutputs"></a>
Inputs and Outputs</h3>
<p>Inputs and Outputs specify data flow. An Output is any Component "computed" value as a function of the state. An Output is used to pass results of computation from one Component to any other, provide fast access to Component calculations (same as a member function call), and collect results without needing to know the details of the source Component and/or its methods.</p>
<div class="image">
<img src="./images/inputs_and_outputs.png"  alt="Figure 4" height="276" width="537"/>
</div>
<p><em>Figure 4. Illustration of the relationship between outputs from one component to the inputs of another components. Here, the activation, force, and length outputs from Muscle object are wired to the inputs of a Reporter object, which then become easily accessible to the user after the simulation completes (see the "Reporter" section below).</em></p>
<p>An [Input](<a class="el" href="classOpenSim_1_1Input.html">OpenSim::Input</a>) is a "slot" that accepts an Output of a specified type. The Input verifies that the Output can be evaluated/consumed as an Input. Inputs allow for a Component to have dependencies on Outputs (that can come from any Component or user-specified Data) rather than a specific Component type (as specified by a <code>Socket&lt;C&gt;</code>).</p>
<p>An [Output](<a class="el" href="classOpenSim_1_1Output.html">OpenSim::Output</a>) is a value of interest generated by a Component (e.g. Muscle has Outputs for its fiber-length and its tension). Outputs are accessed by name and evaluated given a State. Outputs are typed by their value type (e.g. <code>double</code>, <code>Vec3</code>, <code>SpatialVec</code>, <code>Vector</code>).</p>
<p>The Input provides its status as being connected (to an Output) or not. Thus, if an Input is connected to an Output, the Input triggers the evaluation of the Output by the Component to which the Output belongs. If an Output is not needed by any Input it is never evaluated.</p>
<ol type="1">
<li>Single Value Output: A single channel of data. Can be any data type (<code>Vec3</code>, <code>Mat33</code>, <code>double</code>, etc)</li>
<li>List Output: Multiple channels of data. Each channel must be of the same data type</li>
<li>Single Value Input: An input channel that reads one channel of data.</li>
<li>List Input: A list input that reads multiple channels of data of the same type</li>
</ol>
<p>All of a class’s Inputs and Outputs are listed on the Doxygen page for the class.</p>
<p>You can access the number of inputs a Component has, as well as their names: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> numIn = metabolics.getNumInputs();</div><div class="line"><span class="keyword">auto</span> names = metabolics.getInputNames();</div></div><!-- fragment --><p> Once you have their names, you can access a specific Input: </p><div class="fragment"><div class="line">AbstractInput&amp; input = metabolics.updInput(<span class="stringliteral">&quot;activation&quot;</span>);</div></div><!-- fragment --><p> You can ask a specific Input for its data type and whether or not it is connected: </p><div class="fragment"><div class="line"><span class="keywordtype">string</span> type = input.getConnecteeTypeName(); <span class="comment">// result: double</span></div><div class="line"><span class="keywordtype">bool</span> satisfied = input.isConnected();</div></div><!-- fragment --><p> You can connect an Input to an Output like so: </p><div class="fragment"><div class="line">input.connect(soleus.getOutput(<span class="stringliteral">&quot;activation&quot;</span>));</div></div><!-- fragment --><p> If an Input is connected to an Output, you can ask for its value: </p><div class="fragment"><div class="line"><span class="keywordtype">double</span> a = metabolics.getInputValue&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;activation&quot;</span>);</div></div><!-- fragment --><p> There are similar methods for Outputs: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> numOut = metabolics.getNumOutputs();</div><div class="line"><span class="keyword">auto</span> names = metabolics.getOutputNames();</div><div class="line">AbstractOutput&amp; output = metabolics.getOutput(<span class="stringliteral">&quot;heat_rate&quot;</span>);</div><div class="line"><span class="keywordtype">string</span> type = output.getTypeName();</div><div class="line"><span class="keywordtype">string</span> value = output.getValueAsString();</div><div class="line"><span class="keywordtype">double</span> hr = metabolics.getOutputValue&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;heat_rate&quot;</span>);</div></div><!-- fragment --><p> List Outputs may have multiple Channels: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> isList = output.isListOutput();</div></div><!-- fragment --><p> If so, then you could connect individual Channels to an Input: </p><div class="fragment"><div class="line">input.connect(tablesource.getOutput(<span class="stringliteral">&quot;column&quot;</span>).getChannel(<span class="stringliteral">&quot;col1&quot;</span>));</div></div><!-- fragment --><p> If you have a List Input, then you can wire it to multiple Channels (from both one-value and list Outputs): </p><div class="fragment"><div class="line">input.connect(tablesource.getOutput(<span class="stringliteral">&quot;column&quot;</span>).getChannel(<span class="stringliteral">&quot;col1&quot;</span>));</div><div class="line">input.connect(soleus.getOutput(<span class="stringliteral">&quot;activation&quot;</span>));</div></div><!-- fragment --><p> There are cases where an Input might need to "rename" an Output. For example, an InverseKinematics Solver could have a List Input for experimental marker locations, and could require its connectees to be named after markers in the Model. But say the experimental marker that corresponds to the Model’s "toe" marker is called "foot." One can "rename" an output using "annotations": </p><div class="fragment"><div class="line">input.connect(tablesource.getOutput(<span class="stringliteral">&quot;column&quot;</span>).getChannel(<span class="stringliteral">&quot;foot&quot;</span>), <span class="stringliteral">&quot;toe&quot;</span>);</div></div><!-- fragment --><h2>Main Categories of Components</h2>
<h3><a class="anchor" id="operator"></a>
Operator</h3>
<p>An Operator is used to describe a purely functional/mathematical Component. An Operator requires a set of one or more Inputs, it computes on them, and sends its results to a set of one or more Outputs. An Operator has no dependencies on other Components (i.e. Sockets) and does not require a Model to operate (just Inputs). Some examples are arithmetic operations (<code>+,-,*,/</code>), <code>max/min</code>, a <code>delay</code>, and <code>de/multiplexer</code>. They are useful for manipulating the Outputs of other Components, for example, to delay an Output or report its max or min value.</p>
<p>Note: <a class="el" href="namespaceOpenSim.html">OpenSim</a> does not yet contain any built-in Operator components.</p>
<h3><a class="anchor" id="source"></a>
Source</h3>
<p>A Source is a category of components that serves as a source of Outputs (signals) to satisfy model Inputs and that does not itself have any Inputs.</p>
<p><a class="el" href="namespaceOpenSim.html#ad974d56a7e3a9ac6204ef21a1db05b6c">TableSource</a> is one such Component which holds a <code>TimeSeriesTable</code> (see below) and exposes a List Output which contains a Channel for each column of the table.</p>
<h3><a class="anchor" id="reporter"></a>
Reporter</h3>
<p>A <a class="el" href="classOpenSim_1_1Reporter.html">Reporter</a> collects the results of Model computations. It can take any Outputs from a Model (and its Components) as its Inputs. Whether it reports to the terminal, file, or a port is dependent on the concrete Reporter type. Reporters are templated on the datatype of the reported Output&lt;T&gt; type (i.e., a single Reporter can only output one type of data, such as <code>double</code> or <code>Vec3</code>), but there is no limit to the number of Reporters a Model can have.</p>
<div class="image">
<img src="./images/reporters.png"  alt="Figure 5" height="336.5" width="644"/>
</div>
<p><em>Figure 5. Illustration of the Reporter class. As described previously, a Reporter uses inputs to accept quantities outputted from other components. Here, a TableReporter object accepts a Muscle object's quanities as inputs and internally store the data in a TimeSeriesTable. The data can then be accessed by outputting the data to a file (via a FileAdapter) or through the TimeSeriesTable directly.</em></p>
<h3><a class="anchor" id="modelcomponent"></a>
ModelComponent</h3>
<p>A <a class="el" href="classOpenSim_1_1ModelComponent.html">ModelComponent</a> is the base type for all components that can be used to compose a Model. The most common types of ModelComponents are the following:</p>
<ul>
<li><a class="el" href="classOpenSim_1_1PhysicalFrame.html">PhysicalFrame</a>,</li>
<li><a class="el" href="classOpenSim_1_1Joint.html">Joint</a>,</li>
<li><a class="el" href="classOpenSim_1_1Constraint.html">Constraint</a>,</li>
<li><a class="el" href="classOpenSim_1_1Force.html">Force</a>,</li>
<li><a class="el" href="classOpenSim_1_1Actuator.html">Actuator</a>,</li>
<li><a class="el" href="classOpenSim_1_1Controller.html">Controller</a>, and</li>
<li><a class="el" href="classOpenSim_1_1Probe.html">Probe</a>.</li>
</ul>
<p><a class="el" href="namespaceOpenSim.html">OpenSim</a> contains built-in model components for each type above, but users can also create their own model components.</p>
<h2><a class="anchor" id="modelcomponents"></a>
Principal ModelComponents</h2>
<h3><a class="anchor" id="frames"></a>
Frames</h3>
<p><a class="el" href="classOpenSim_1_1Frame.html">Frame</a> is an <a class="el" href="namespaceOpenSim.html">OpenSim</a> representation of a reference frame in which the spatial location and orientation of other Frames can be described. Every Model has a <a class="el" href="classOpenSim_1_1Ground.html">Ground</a> frame in which all other Frames can be measured. A Frame consists of a right-handed set of three orthogonal axes and an origin point. Frames provide a convenient way to locate physical structures, such as joints and muscle attachments. Frames also provide a convenient basis for performing spatial calculations. For example, if your system includes contact, you might define a Frame that is aligned with the normal direction of a contact surface and whose origin is at the center-of-pressure. You can then easily report the contact forces normal to the contact surface and the location of the center-of-pressure, without repeatedly performing the transformations in your main or analysis code.</p>
<p>There are several types of Frames:</p>
<ol type="1">
<li><a class="el" href="classOpenSim_1_1PhysicalFrame.html">PhysicalFrame</a>: supports physical connections (e.g., Joints, Constraints) and is the Frame type to which forces can be applied. A concrete example of a PhysicalFrame is a Body. PhysicalFrame is an abstract class.</li>
<li><a class="el" href="classOpenSim_1_1Ground.html">Ground</a>: an inertial reference frame in which the motion of all Frames and Points may conveniently and efficiently be expressed. As a PhysicalFrame, Ground supports physical connections by joints, constraints and forces can be applied to it.</li>
<li><a class="el" href="classOpenSim_1_1Body.html">Body</a>: a PhysicalFrame with inertia. A Body is specified by its mass, a center-of-mass located in the PhysicalFrame, and its moment of inertia tensor about the center-of-mass.</li>
<li><a class="el" href="classOpenSim_1_1PhysicalOffsetFrame.html">PhysicalOffsetFrame</a>: a type of Physical Frame whose transform is specified as a constant offset from another Physical Frame. For example, PhysicalOffsetFrames can be used to specify the location and orientation of a Joint or Constraint on a Body.</li>
</ol>
<p>The following diagram illustrates how each type of PhysicalFrame might appear in a model.</p>
<div class="image">
<img src="./images/physical_frames_figure.png"  alt="PhysicalFrames" height="800" width="1024"/>
</div>
<p>(Note: "ComputedFrame" does not yet exist in <a class="el" href="namespaceOpenSim.html">OpenSim</a>, but you could create it yourself!)</p>
<p>Every Frame is capable of providing its Transform (translation of the origin and the orientation of its axes) in the Ground frame as a function of the State and provides convenience methods for re-expressing vectors from one Frame to another.</p>
<p>It is perhaps less evident that Frames can be extremely useful for linking a multitude of reference frames together to form chains and trees. For example, a Frame to specify muscle attachments (M) and a Frame to specify a joint location (J) could themselves be specified in an anatomical Frame (A) defined by bony landmarks identified by surface markers or tagged on CT or MRI images. The body (B), to which the anatomical frame (A) is attached, can be thought of as a "Base" frame or a root of a tree from which a set of descendant frames arise. In particular, a Base frame and all its descendants have the property that they share the same angular velocity, since they are affixed to the same underlying Frame (in this case a Body).</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;      M---muscle points</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;     /</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;B---A</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;     \</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;      J---joint axes</div></div><!-- fragment --><p>Given this tree, both the muscle attachment points (in M) and the joint axes, J, change when the anatomical frame, A, changes with respect to the base, B, without requiring muscle attachments and joint axes to be manually adjusted. Consequently, a useful concept is that of a Base frame, and a Frame can always provide its Base frame. If a Frame is not affixed to another frame, its Base frame is itself.</p>
<h3><a class="anchor" id="points"></a>
Points, Stations and Markers</h3>
<p>A <a class="el" href="classOpenSim_1_1Point.html">Point</a> is an <a class="el" href="namespaceOpenSim.html">OpenSim</a> representation of any location in space. Points can be used to define and compute the location of physical structures (such as points of constraints and points of muscle attachments). Points can also embody the results of spatial calculations. For example, if your system involves contact, you can define a Point that describes the location of the center-of-pressure as one element rolls over another.</p>
<p>A Point provides its location, velocity, and acceleration in the Ground frame as a function of the Model’s state, as long as the state has been realized to the appropriate stage (Position, Velocity, or Acceleration)</p>
<ol type="1">
<li><a class="el" href="classOpenSim_1_1Point.html">Point</a>: an abstraction for any location in space</li>
<li><a class="el" href="classOpenSim_1_1Station.html">Station</a>: a Point fixed to a PhysicalFrame</li>
<li><a class="el" href="classOpenSim_1_1Marker.html">Marker</a>: a Station that represents a motion capture marker from an experiment</li>
</ol>
<p><a class="el" href="namespaceOpenSim.html">OpenSim</a> Stations are Points defined in Euclidian space. They are defined with a three element column vector (Vec3), relative to their parent Frame. Stations are thus analogous to PhysicalOffsetFrames in that constraints and forces can be attached and/or applied to them.</p>
<h3><a class="anchor" id="joints"></a>
Joints</h3>
<ul>
<li><a class="el" href="classOpenSim_1_1Joint.html">Joint</a></li>
</ul>
<h3><a class="anchor" id="constraints"></a>
Constraints</h3>
<ul>
<li><a class="el" href="classOpenSim_1_1Constraint.html">Constraint</a></li>
</ul>
<h3><a class="anchor" id="forces"></a>
Forces</h3>
<p><a class="el" href="classOpenSim_1_1Force.html">Force</a></p><ul>
<li><a class="el" href="classOpenSim_1_1PointToPointSpring.html">PointToPointSpring</a></li>
<li><b>ContactForces</b><ul>
<li><a class="el" href="classOpenSim_1_1HuntCrossleyForce.html">HuntCrossleyForce</a></li>
<li><a class="el" href="classOpenSim_1_1ElasticFoundationForce.html">ElasticFoundationForce</a></li>
</ul>
</li>
</ul>
<h3><a class="anchor" id="actuators"></a>
Actuators</h3>
<p><a class="el" href="classOpenSim_1_1Actuator.html">Actuator</a></p><ul>
<li><a class="el" href="classOpenSim_1_1CoordinateActuator.html">CoordinateActuator</a></li>
<li><a class="el" href="classOpenSim_1_1Muscle.html">Muscle</a></li>
</ul>
<h3><a class="anchor" id="controller"></a>
Controllers</h3>
<p><a class="el" href="classOpenSim_1_1Controller.html">Controller</a></p>
<h2><a class="anchor" id="datahandling"></a>
Data Handling Classes</h2>
<h3>Data Table</h3>
<p><a class="el" href="namespaceOpenSim.html#a376c9e7e093c70e2af26ac7c47c9a320">DataTable</a> is an in-memory storage container for data with support for holding metadata. DataTables provide a single, unified method for storing and accessing data, such as results generated by Components. Reporter and Source components may use DataTables internally. They provide fast access to numerical elements and to complete rows and columns of data, by index and by column names. DataTables are independent of any particular file format.</p>
<p>DataTables contain a single "independent" column and a set of dependent columns. The independent column can be any scalar data type (e.g., <code>int</code>, <code>float</code>, <code>double</code>). The dependent columns can be of any data type (<code>double</code>, <code>Vec3</code>, <code>Mat33</code>, <code>SpatialVec</code>, etc.). All of the dependent columns must be of the same data type. Each independent and dependent column, as well as the entire table, can contain metadata.</p>
<h3>Data Adapter</h3>
<p><a class="el" href="classOpenSim_1_1DataAdapter.html">DataAdapter</a> is an abstract class that defines an interface for reading and writing the contents of a DataTable.</p>
<p>The DataAdapter separates use of a DataTable from the various sources of data, including streams, files, databases, and devices. A DataAdapter is how you read from or write to different sources of data. Concrete classes handle the particular interface and format of a given data source.</p>
<p><a class="el" href="classOpenSim_1_1FileAdapter.html">FileAdapter</a> offers an interface to read and write files through the following methods. </p><div class="fragment"><div class="line">FileAdapter::read(<span class="keywordtype">string</span> fileName)</div><div class="line">FileAdapter::write(<span class="keywordtype">string</span> fileName)</div></div><!-- fragment --><p>Based on the extension part of the filename, these methods invoke one of the following concrete FileAdapters to perform the read/write.</p>
<ol type="1">
<li><a class="el" href="classOpenSim_1_1TRCFileAdapter.html">TRCFileAdapter</a>: reads and writes TRC files.</li>
<li><a class="el" href="namespaceOpenSim.html#afe33d0d17877a8100ddc931e20787908">STOFileAdapter</a>: reads and writes STO files.</li>
<li><a class="el" href="classOpenSim_1_1CSVFileAdapter.html">CSVFileAdapter</a>: reads and writes CSV files.</li>
<li><a class="el" href="classOpenSim_1_1C3DFileAdapter.html">C3DFileAdapter</a>: reads C3D files.</li>
</ol>
<p>While it is possible to invoke the concrete FileAdapters above for reading data files, it is often more intuitive to think about what type of DataTable you want to read, rather than which Adapter class to use. Thus we provide constructors to create tables from files using the appropriate FileAdapters internally. For example, to read a TimeSeriesTableVec3 of marker data from a TRC file you can use: </p><div class="fragment"><div class="line"><a class="code" href="namespaceOpenSim.html#aca67cce5245fc8a1ac274999aa98deb6">TimeSeriesTableVec3</a> markersTable(<span class="stringliteral">&quot;markerDataFile.trc&quot;</span>); </div><div class="line"><a class="code" href="namespaceOpenSim.html#a39e2414750443cfa41c224f5cdd31bac">TimeSeriesTable</a> coordinates(<span class="stringliteral">&quot;kinematics.sto&quot;</span>);</div></div><!-- fragment --><h2><a class="anchor" id="solvers"></a>
Solvers</h2>
<p>A Solver is an abstraction to capture an algorithm/process to compute System unknowns of a Model. For example, the <a class="el" href="classOpenSim_1_1InverseKinematicsSolver.html">InverseKinematicsSolver</a> operates on the System underlying a Model to determine the generalized coordinate (state variable) values that satisfy external measurements (Markers). The <a class="el" href="classOpenSim_1_1MomentArmSolver.html">MomentArmSolver</a> evaluates a muscle path to determine the effectiveness of a muscle to generate a generalized force about or along a coordinate.</p>
<p>The <a class="el" href="classOpenSim_1_1Manager.html">Manager</a> currently serves as a "ForwardDynamics" Solver which integrates the System dynamics forward in time. We intend to provide a ForwardDynamicsSolver that returns a StatesTrajectory. In the meantime, you can generate a StatesTrajectory by implementing your own simulation function, like this: </p><div class="fragment"><div class="line">StatesTrajectory <a class="code" href="namespaceOpenSim.html#a5821a4ca8e6fe9b0cb2b5492665b5dc0">simulate</a>(<span class="keyword">const</span> Model&amp; model, <span class="keyword">const</span> State&amp;</div><div class="line"> initState,     <span class="keywordtype">double</span> finalTime) {</div><div class="line">    StatesTrajectory states;</div><div class="line">    SimTK::RungeKuttaMersonIntegrator integrator(model.getSystem());</div><div class="line">    SimTK::TimeStepper ts(model.getSystem(), integrator);</div><div class="line">    ts.initialize(initState);</div><div class="line">    ts.setReportAllSignificantStates(<span class="keyword">true</span>);</div><div class="line">    integrator.setReturnEveryInternalStep(<span class="keyword">true</span>);</div><div class="line">    <span class="keywordflow">while</span> (ts.getState().getTime() &lt; finalTime) {</div><div class="line">        ts.stepTo(finalTime);</div><div class="line">        <span class="comment">// StatesTrajectory API for appending states:</span></div><div class="line">        states.append(ts.getState());</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> states;</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="writingcomponents"></a>
Writing your own Component</h1>
<p>The main task for Components (as part of a Model) is to generate a System. When the underlying System is built, all the variables in the system of equations appear in the State. A Component, therefore, is responsible for adding state variables to the system and providing access to those variables. The system can (and typically does) obtain default values for state variables from the Component’s properties.</p>
<h4>The responsibility of the Component builder is four-fold:</h4>
<ol type="1">
<li>Construct the structural attributes of the component: its properties (serializable attributes), sockets (structural dependencies), inputs (signals it needs) and outputs (signals/values, results) that it will produce.</li>
<li>Finalize data members that are dependent on your properties and add relevant checks to ensure your component is connected properly. With a Component finalized and connected, it is time to translate your Component into equations of the System and its variables into the corresponding State. Once a system is built, changes to any Component properties and connections will invalidate the System and the System must be rebuilt.</li>
<li>Add the necessary multibody elements to the system, and any other dynamics described as a system of first order ODEs. This involves allocating and adding state variables and specifying their time derivatives.</li>
<li>initialize the state variables allocated by your component, which generally involves using properties either to hold initial values or to compute them. The inverse operation of converting a state into properties for use another time is also helpful.</li>
</ol>
<h2><a class="anchor" id="constructproperties"></a>
I. Constructing your Component’s Attributes</h2>
<ol type="1">
<li>Derive your component from the base component type you want to extend. You may derive from that class or its parent. If your component is completely new, you can derive directly from Component or ModelComponent, but that is generally a bit more work, since the base classes for the different types do a lot of the hookups (that follow) for you.</li>
<li>Construct your component with the properties (elements that appear in XML) you want. You must first define the properties you want to expose by calling one of the <code>OpenSim_DECLARE_PROPERTY</code> macros, which you use to specify the name, type and description of the property. NOTE: your class automatically has <code>get/set_&lt;property_name&gt;()</code> methods when you apply the macro, and the properties and corresponding methods are inherited from its parent class. <div class="fragment"><div class="line"><a class="code" href="classOpenSim_1_1Property.html#aa3ae917a7d77f92f49f7a0fb4cbed75b">OpenSim_DECLARE_PROPERTY</a>(gain, <span class="keywordtype">double</span>, <span class="stringliteral">&quot;Controller gain.&quot;</span>);</div><div class="line"><a class="code" href="classOpenSim_1_1Property.html#aaf2e667234fb198a5dacb6fd7c1b62e8">OpenSim_DECLARE_LIST_PROPERTY</a>(functions, Function,</div><div class="line">        <span class="stringliteral">&quot;Functions are used to compute the force applied to bodies.&quot;</span>);</div></div><!-- fragment --></li>
<li>Invoke the individual <code>constructProperty_&lt;property_name&gt;()</code> methods for each property you have declared and assign them default values in each constructor. If you have multiple properties and constructors it is convenient to create a function <code>void constructProperties()</code> as a private method that can be called from each constructor. <div class="fragment"><div class="line"><span class="keyword">public</span>:</div><div class="line">    MyController() { constructProperties(); }</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> constructProperties() {</div><div class="line">        constructProperty_gain(10);</div><div class="line">        constructProperty_functions();</div><div class="line">    }</div></div><!-- fragment --></li>
<li>If you have dependencies on other components you should specify those dependencies by using the <code>OpenSim_DECLARE_SOCKET</code> macro with the Socket name and type of the dependency. For example, a Joint has two sockets of type PhysicalFrame and their names are <em>parent_frame</em> and <em>child_frame</em> respectively. Sockets automatically generate properties with socket type and name as part of the XML tag. The expected XML value is the full path name of the dependency component. <a class="el" href="namespaceOpenSim.html">OpenSim</a> can now check the existence of the dependency, and ensure it is of the correct type. If the dependency is not satisfied, <a class="el" href="namespaceOpenSim.html">OpenSim</a> will provide meaningful error messages. <div class="fragment"><div class="line"><a class="code" href="classOpenSim_1_1Socket.html#a6550596c50d489a2ebc6cb0d3c422689">OpenSim_DECLARE_SOCKET</a>(muscle, Muscle,</div><div class="line">        <span class="stringliteral">&quot;The muscle for which to compute metabolic rate.&quot;</span>);</div></div><!-- fragment --></li>
<li>Specify your component’s Outputs by employing the <code>OpenSim_DECLARE_OUTPUT</code> macro with the name of the output, its value type, and the member function of your component that produces the value of the output. Similarly, use the <code>OpenSim_DECLARE_INPUT</code> macro to create a named slot for the Output of another component to plug in. <div class="fragment"><div class="line"><a class="code" href="classOpenSim_1_1Input.html#a6a1f5ba420d43938242a03319b69727c">OpenSim_DECLARE_INPUT</a>(desired_angle, <span class="keywordtype">double</span>, SimTK::Stage::Position,</div><div class="line">        <span class="stringliteral">&quot;This controller will try to minimize the error from this angle (radians).&quot;</span>);</div><div class="line"></div><div class="line"><a class="code" href="classOpenSim_1_1Output.html#af8bbcf81ac2c3691d456921578ba0994">OpenSim_DECLARE_OUTPUT</a>(heat_rate, <span class="keywordtype">double</span>, SimTK::Stage::Dynamics,</div><div class="line">        calcHeatRate);</div></div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="finalizefromproperties"></a>
II. Finalize Properties and Connections of the Component</h2>
<p>All components are given the opportunity finalize their specification from their properties, which occurs during <code><a class="el" href="classOpenSim_1_1Component.html#a94531c6dfb2490ef235d05e7911fcc94" title="Define a Component&#39;s internal data members and structure according to its properties. ">OpenSim::Component::finalizeFromProperties()</a></code>. The base (Component) implementation also makes sure Components that are properties (e.g. a BodySet, JointSet) are included as subcomponents. As subcomponents, any actions invoked on the top-level component invokes its subcomponents, automatically. For example, <code>finalizeFromProperties()</code> is invoked on the subcomponents. To add custom functionality to your Component:</p>
<ol type="1">
<li>Override <code><a class="el" href="classOpenSim_1_1Component.html#a9ac1a495f4798883a1ede6e71463e752" title="Perform any time-invariant calculations, data structure initializations, or other configuration based...">OpenSim::Component::extendFinalizeFromProperties()</a></code> to perform any data loading or conversions that the Component will need during a simulation. For example, the Body component has a property that contains six numbers intended to be the moments and products of inertia of a physical body. Body overrides <code>extendFinalizeFromProperties()</code> to convert those 6 numbers to a proper SimTK::Inertia, which will throw pertinent exceptions about the validity of those numbers to form a physical inertia tensor. Note, that the base <code>Component::finalizeFromProperties()</code> marks the component as being up-to-date with its properties. We indicate virtual methods intended for Component writers to extend the basic operations of a Component by using "extend" in the virtual function name. <div class="fragment"><div class="line"><span class="keywordtype">void</span> extendFinalizeFromProperties() {</div><div class="line">    Super::extendFinalizeFromProperties();</div><div class="line">    <span class="keywordflow">if</span> (get_default_activation() &lt; 0)</div><div class="line">        <span class="keywordflow">throw</span> Exception(<span class="stringliteral">&quot;Negative default activation.&quot;</span>);</div><div class="line">}</div></div><!-- fragment --></li>
<li>Similarly, Sockets are handled automatically by the base Component, which establishes that the dependency exists and is connected (throws an Exception otherwise). Additional connection details or checks are often necessary, in which case you must override: <div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classOpenSim_1_1Component.html#aa21ecf04527f314b77d5e4416b4c77ef">OpenSim::Component::extendFinalizeConnections</a>(Component&amp; root)</div></div><!-- fragment --> for a Component, or <div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classOpenSim_1_1ModelComponent.html#a6322286eb249c75be0082b406d3b6680">OpenSim::ModelComponent::extendConnectToModel</a>(Model&amp; model)</div></div><!-- fragment --> for a ModelComponent. Here you can verify that the components that satisfy its sockets also satisfy other conditions: for example, that the connectees are unique (e.g. a Joint requires parent and child to not be the same PhysicalFrame). Inputs are automatically connected based on the Output name. However, if you know the output you need (e.g. a Muscle for a MetabolicCalculator), you can directly form the Input connection like this: <div class="fragment"><div class="line">getInput(<span class="stringliteral">&quot;fiber_vel&quot;</span>).connect(muscle.getOutput(<span class="stringliteral">&quot;fiber_velocity&quot;</span>));</div></div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="addtosystem"></a>
III. Adding your Component’s Dynamics to the System</h2>
<ol type="1">
<li>Override <code>void <a class="el" href="classOpenSim_1_1Component.html#aa1dd206dd39567bef473471ba71fa19e" title="Add appropriate Simbody elements (if needed) to the System corresponding to this component and specif...">OpenSim::Component::extendAddToSystem(SimTK::MultibodySystem&amp; system) const</a></code> and add Simbody elements to the System. It is important to note that you must maintain the underlying indices so your component can access the Simbody elements later if necessary. Classes like Joint, Constraint, and Force provide methods to help you create new types of these Components and manage the indices for you. Ask for help if you want to expose state variables allocated by underlying Simbody elements.</li>
<li>If you have component dynamics that you will model as ordinary differential equations (ODEs) you must also add the corresponding state variable(s) to the system’s state also in <code>extendAddToSystem()</code> by invoking <code>addStateVariable()</code>. If you can express your component dynamics as a function of the state: <em>zdot = F(state)</em>, then z is the state variable added by your component.</li>
<li>The function (e.g. <em>F(state)</em> above) that determines the time derivative of your state must be implemented in <code>void <a class="el" href="classOpenSim_1_1Component.html#a957e6487d7de4cabad03c788cb7150f6" title="If a model component has allocated any continuous state variables using the addStateVariable() method...">OpenSim::Component::computeStateVariableDerivatives(const SimTK::State&amp; s) const</a></code>, which you override.</li>
<li>NOTE: Any value that your dynamics depends on that isn’t a constant must itself be a state variable or an Input. If the values are provided externally (e.g. user-supplied) the values must be held as discrete state variables and they are similarly allocated by <code><a class="el" href="classOpenSim_1_1Component.html#a0c7a974ec1ba8ed7e2ed175f561c1dd5" title="Add a system discrete variable belonging to this Component, give it a name by which it can be referen...">OpenSim::Component::addDiscreteVariable()</a></code> and must be set before the dynamics of the Component are realized. <div class="fragment"><div class="line"><span class="keywordtype">void</span> extendAddToSystem(SimTK::MultibodySystem&amp; sys)<span class="keyword"> const override </span>{</div><div class="line">    Super::extendAddToSystem(sys);        </div><div class="line">    addStateVariable(<span class="stringliteral">&quot;activation&quot;</span>); addCacheVariable(<span class="stringliteral">&quot;fiber_force&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> computeStateVariableDerivatives(<span class="keyword">const</span> SimTK::State&amp; s)<span class="keyword"> const override </span>{</div><div class="line">    Super::computeStateVariableValueDerivatives(s);</div><div class="line">    setStateVariableDerivativeValue(s, <span class="stringliteral">&quot;activation&quot;</span>, ...);                    </div><div class="line">}</div></div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="initstatefromproperties"></a>
IV. Initializing and Recalling the State</h2>
<ol type="1">
<li>It is good practice to initialize your component’s state variables, so that the component and the Model as a whole can simulate without user input. For example, Coordinates maintain "default_value" and "default_speed" properties for this purpose. The translation from properties to state variable values is implemented by <code>void <a class="el" href="classOpenSim_1_1Component.html#afee6008dcc47f3109bd26e08fc7d81a0" title="Transfer property values or other state-independent initial values into this component&#39;s state variab...">OpenSim::Component::extendInitStateFromProperties(SimTK::State&amp; state) const</a></code>, which you can override to initialize all the component's state variables from properties. <div class="fragment"><div class="line"><span class="keywordtype">void</span> extendInitStateFromProperties(SimTK::State&amp; s)<span class="keyword"> const override </span>{</div><div class="line">    Super::extendInitStateFromProperties(s);</div><div class="line">    setStateVariableValue(s, <span class="stringliteral">&quot;activation&quot;</span>, get_default_activation());</div><div class="line">}</div></div><!-- fragment --></li>
<li>Overriding <code>void <a class="el" href="classOpenSim_1_1Component.html#abd485ed583b2b7be1c3cc00822fc3c2d" title="Update this component&#39;s property values to match the specified State, if the component has created an...">OpenSim::Component::extendSetPropertiesFromState(const SimTK::State&amp; state)</a></code> enables you to perform the inverse operation and to update the property (e.g., the default_value) from the value in the State, for instance after a forward simulation. Ideally, your component should enable a simulation to be stopped, the state values held as properties, the model saved, then reloaded, initialized from its properties and the simulation resumed, such that concatenation of the two simulations is identical to performing a single simulation of longer duration. <div class="fragment"><div class="line"><span class="keywordtype">void</span> extendSetPropertiesFromState(<span class="keyword">const</span> SimTK::State&amp; s)<span class="keyword"> const override </span>{</div><div class="line">    Super::extendSetPropertiesFromState(s);</div><div class="line">    set_default_activation(getStateVariableValue(s, <span class="stringliteral">&quot;activation&quot;</span>));        </div><div class="line">}</div></div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="testComponents"></a>
Test Components</h2>
<p>While testing the dynamics of your Component and its results is best left to you, the Component builder, <a class="el" href="namespaceOpenSim.html">OpenSim</a> provides a test harness for testing the structure and integrity of your Component. The test program in testComponents.cpp instantiates and performs some standard checks on each Component in its queue, to which you can add your Component, to test:</p><ol type="1">
<li>serialization and deserialization and their equivalence</li>
<li>cloning (copying) with its equivalence to the original</li>
<li>memory increases due to copying</li>
<li>adding the component to a Model</li>
<li>the use of Sockets to define and satisfy dependencies</li>
<li>initializing the System (calling <code><a class="el" href="classOpenSim_1_1Model.html#aaa4bbbfcb5ea9de9f2605eb6b0e886e5" title="Convenience method that invokes buildSystem() and then initializeState(). ">OpenSim::Model::initSystem()</a></code>) and its impact on memory</li>
<li>evaluating Outputs at the Stage indicated by the Output. </li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Feb 6 2020 19:07:55 for API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
