<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>API: OpenSim::Set&lt; T, C &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen_user.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenSimLogoWhiteHorizontal_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">API
   &#160;<span id="projectnumber">4.1</span>
   </div>
   <div id="projectbrief">For MATLAB, Python, Java, and C++ users</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Class&#160;Groups</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List&#160;</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classOpenSim_1_1Set.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classOpenSim_1_1Set-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">OpenSim::Set&lt; T, C &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class for holding a set of pointers to objects.  
 <a href="classOpenSim_1_1Set.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for OpenSim::Set&lt; T, C &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classOpenSim_1_1Set.png" usemap="#OpenSim::Set_3C_20T_2C_20C_20_3E_map" alt=""/>
  <map id="OpenSim::Set_3C_20T_2C_20C_20_3E_map" name="OpenSim::Set&lt; T, C &gt;_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a608e97adc15002fcdaec6736d0512500"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a608e97adc15002fcdaec6736d0512500">~Set</a> ()</td></tr>
<tr class="memdesc:a608e97adc15002fcdaec6736d0512500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a608e97adc15002fcdaec6736d0512500">More...</a><br /></td></tr>
<tr class="separator:a608e97adc15002fcdaec6736d0512500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abca0e3a7e5691d3df7c5476ee676019b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#abca0e3a7e5691d3df7c5476ee676019b">Set</a> ()</td></tr>
<tr class="memdesc:abca0e3a7e5691d3df7c5476ee676019b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#abca0e3a7e5691d3df7c5476ee676019b">More...</a><br /></td></tr>
<tr class="separator:abca0e3a7e5691d3df7c5476ee676019b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f3485a26c614942c5b004761c2f1fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a46f3485a26c614942c5b004761c2f1fa">Set</a> (const std::string &amp;aFileName, bool aUpdateFromXMLNode=true)</td></tr>
<tr class="memdesc:a46f3485a26c614942c5b004761c2f1fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from file.  <a href="#a46f3485a26c614942c5b004761c2f1fa">More...</a><br /></td></tr>
<tr class="separator:a46f3485a26c614942c5b004761c2f1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8721e5e16a595e9894c2ae97aeb8e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#adf8721e5e16a595e9894c2ae97aeb8e4">Set</a> (const <a class="el" href="classOpenSim_1_1Set.html">Set</a>&lt; T, C &gt; &amp;aSet)</td></tr>
<tr class="memdesc:adf8721e5e16a595e9894c2ae97aeb8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#adf8721e5e16a595e9894c2ae97aeb8e4">More...</a><br /></td></tr>
<tr class="separator:adf8721e5e16a595e9894c2ae97aeb8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ef09b96382c20ba4e220a2541f2bda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a40ef09b96382c20ba4e220a2541f2bda">setupGroups</a> ()</td></tr>
<tr class="memdesc:a40ef09b96382c20ba4e220a2541f2bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setup groups (match group member names to set members).  <a href="#a40ef09b96382c20ba4e220a2541f2bda">More...</a><br /></td></tr>
<tr class="separator:a40ef09b96382c20ba4e220a2541f2bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b854682659a2a4dbdff82cc7d5a553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1Set.html">Set</a>&lt; T, C &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a06b854682659a2a4dbdff82cc7d5a553">operator=</a> (const <a class="el" href="classOpenSim_1_1Set.html">Set</a>&lt; T, C &gt; &amp;<a class="el" href="classOpenSim_1_1Set.html#aeced14b2425baebc463132a3e1caf22d">set</a>)</td></tr>
<tr class="memdesc:a06b854682659a2a4dbdff82cc7d5a553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign this set to another set.  <a href="#a06b854682659a2a4dbdff82cc7d5a553">More...</a><br /></td></tr>
<tr class="separator:a06b854682659a2a4dbdff82cc7d5a553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc219f936f53dfed9c78c97dbc781736"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#abc219f936f53dfed9c78c97dbc781736">operator[]</a> (int aIndex) const </td></tr>
<tr class="memdesc:abc219f936f53dfed9c78c97dbc781736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the set object at a specified index.  <a href="#abc219f936f53dfed9c78c97dbc781736">More...</a><br /></td></tr>
<tr class="separator:abc219f936f53dfed9c78c97dbc781736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532132c98808305e0e5ec179a5368008"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a532132c98808305e0e5ec179a5368008">setMemoryOwner</a> (bool aTrueFalse)</td></tr>
<tr class="memdesc:a532132c98808305e0e5ec179a5368008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether or not this <a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> owns the memory pointed to by the pointers it holds.  <a href="#a532132c98808305e0e5ec179a5368008">More...</a><br /></td></tr>
<tr class="separator:a532132c98808305e0e5ec179a5368008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97d610cbb9f8ece390d7e849ee7cc72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#ac97d610cbb9f8ece390d7e849ee7cc72">getMemoryOwner</a> () const </td></tr>
<tr class="memdesc:ac97d610cbb9f8ece390d7e849ee7cc72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether or not this array owns the memory pointed to by the pointers in its array.  <a href="#ac97d610cbb9f8ece390d7e849ee7cc72">More...</a><br /></td></tr>
<tr class="separator:ac97d610cbb9f8ece390d7e849ee7cc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ddd97e9cf8a4b759e2e46f8d97e136c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a1ddd97e9cf8a4b759e2e46f8d97e136c">computeNewCapacity</a> (int aMinCapacity, int &amp;rNewCapacity)</td></tr>
<tr class="memdesc:a1ddd97e9cf8a4b759e2e46f8d97e136c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a new capacity that is at least as large as a specified minimum capacity; this method does not change the capacity, it simply computes a new recommended capacity.  <a href="#a1ddd97e9cf8a4b759e2e46f8d97e136c">More...</a><br /></td></tr>
<tr class="separator:a1ddd97e9cf8a4b759e2e46f8d97e136c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0db50c56a783c3ad288e060528b89bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#ac0db50c56a783c3ad288e060528b89bd">ensureCapacity</a> (int aCapacity)</td></tr>
<tr class="memdesc:ac0db50c56a783c3ad288e060528b89bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that the capacity of this array is at least the specified amount.  <a href="#ac0db50c56a783c3ad288e060528b89bd">More...</a><br /></td></tr>
<tr class="separator:ac0db50c56a783c3ad288e060528b89bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a39d7a869b76794fb11cf41439014c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a5a39d7a869b76794fb11cf41439014c8">trim</a> ()</td></tr>
<tr class="memdesc:a5a39d7a869b76794fb11cf41439014c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trim the capacity of this array so that it is one larger than the size of this array.  <a href="#a5a39d7a869b76794fb11cf41439014c8">More...</a><br /></td></tr>
<tr class="separator:a5a39d7a869b76794fb11cf41439014c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cba82725570aa40ca1cc97a1697328"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a13cba82725570aa40ca1cc97a1697328">getCapacity</a> () const </td></tr>
<tr class="memdesc:a13cba82725570aa40ca1cc97a1697328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the capacity of this storage instance.  <a href="#a13cba82725570aa40ca1cc97a1697328">More...</a><br /></td></tr>
<tr class="separator:a13cba82725570aa40ca1cc97a1697328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a9810443f5b1600316a84615838fe5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#ab9a9810443f5b1600316a84615838fe5">setCapacityIncrement</a> (int aIncrement)</td></tr>
<tr class="memdesc:ab9a9810443f5b1600316a84615838fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the amount by which the capacity is increased when the capacity of of the array in exceeded.  <a href="#ab9a9810443f5b1600316a84615838fe5">More...</a><br /></td></tr>
<tr class="separator:ab9a9810443f5b1600316a84615838fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3299aa1bf89c85e7bce9fa219034e4c1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a3299aa1bf89c85e7bce9fa219034e4c1">getCapacityIncrement</a> () const </td></tr>
<tr class="memdesc:a3299aa1bf89c85e7bce9fa219034e4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the amount by which the capacity is increased.  <a href="#a3299aa1bf89c85e7bce9fa219034e4c1">More...</a><br /></td></tr>
<tr class="separator:a3299aa1bf89c85e7bce9fa219034e4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092511a68bb319cbf647b64b0e35feee"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a092511a68bb319cbf647b64b0e35feee">setSize</a> (int aSize)</td></tr>
<tr class="memdesc:a092511a68bb319cbf647b64b0e35feee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of the array.  <a href="#a092511a68bb319cbf647b64b0e35feee">More...</a><br /></td></tr>
<tr class="separator:a092511a68bb319cbf647b64b0e35feee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a129d0a6e121754ca38cb28afdd343a2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a129d0a6e121754ca38cb28afdd343a2d">getSize</a> () const </td></tr>
<tr class="memdesc:a129d0a6e121754ca38cb28afdd343a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the array.  <a href="#a129d0a6e121754ca38cb28afdd343a2d">More...</a><br /></td></tr>
<tr class="separator:a129d0a6e121754ca38cb28afdd343a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c13fe73297891a888ffd954f2a831f7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a7c13fe73297891a888ffd954f2a831f7">getIndex</a> (const T *aObject, int aStartIndex=0) const </td></tr>
<tr class="memdesc:a7c13fe73297891a888ffd954f2a831f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of an object.  <a href="#a7c13fe73297891a888ffd954f2a831f7">More...</a><br /></td></tr>
<tr class="separator:a7c13fe73297891a888ffd954f2a831f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ddd31a4131d7c7805f9858614ba25f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#ae3ddd31a4131d7c7805f9858614ba25f">getIndex</a> (const std::string &amp;aName, int aStartIndex=0) const </td></tr>
<tr class="memdesc:ae3ddd31a4131d7c7805f9858614ba25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of an object by specifying its name.  <a href="#ae3ddd31a4131d7c7805f9858614ba25f">More...</a><br /></td></tr>
<tr class="separator:ae3ddd31a4131d7c7805f9858614ba25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04be479fb15d7493ec279e8141537d64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a04be479fb15d7493ec279e8141537d64">getGroupNamesContaining</a> (const std::string &amp;aObjectName, <a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; std::string &gt; &amp;rGroupNames) const </td></tr>
<tr class="memdesc:a04be479fb15d7493ec279e8141537d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get names of groups containing a given object.  <a href="#a04be479fb15d7493ec279e8141537d64">More...</a><br /></td></tr>
<tr class="separator:a04be479fb15d7493ec279e8141537d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d22c0e373cd80a65bfa01c1f20a6a0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a39d22c0e373cd80a65bfa01c1f20a6a0">adoptAndAppend</a> (T *aObject)</td></tr>
<tr class="memdesc:a39d22c0e373cd80a65bfa01c1f20a6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append to the array, and adopt passed in pointer.  <a href="#a39d22c0e373cd80a65bfa01c1f20a6a0">More...</a><br /></td></tr>
<tr class="separator:a39d22c0e373cd80a65bfa01c1f20a6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6704c1f65f94f1fd251577cf411d5c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a2e6704c1f65f94f1fd251577cf411d5c">cloneAndAppend</a> (const T &amp;aObject)</td></tr>
<tr class="memdesc:a2e6704c1f65f94f1fd251577cf411d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">cloneAndAppend creates a clone of the passed in object and appends the clone to the array.  <a href="#a2e6704c1f65f94f1fd251577cf411d5c">More...</a><br /></td></tr>
<tr class="separator:a2e6704c1f65f94f1fd251577cf411d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf1da111571bb1f156da8ab169181a48"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#adf1da111571bb1f156da8ab169181a48">insert</a> (int aIndex, T *aObject)</td></tr>
<tr class="memdesc:adf1da111571bb1f156da8ab169181a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an object into the array at a specified index.  <a href="#adf1da111571bb1f156da8ab169181a48">More...</a><br /></td></tr>
<tr class="separator:adf1da111571bb1f156da8ab169181a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79a11b57529978ce78c9dc28771bfe2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#af79a11b57529978ce78c9dc28771bfe2">insert</a> (int aIndex, const T &amp;aObject)</td></tr>
<tr class="memdesc:af79a11b57529978ce78c9dc28771bfe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an object into the array at a specified index.  <a href="#af79a11b57529978ce78c9dc28771bfe2">More...</a><br /></td></tr>
<tr class="separator:af79a11b57529978ce78c9dc28771bfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a403c4fee4095464d6e9d92aaa512c1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a2a403c4fee4095464d6e9d92aaa512c1">remove</a> (int aIndex)</td></tr>
<tr class="memdesc:a2a403c4fee4095464d6e9d92aaa512c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an object from the array at a specified index.  <a href="#a2a403c4fee4095464d6e9d92aaa512c1">More...</a><br /></td></tr>
<tr class="separator:a2a403c4fee4095464d6e9d92aaa512c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f85901afbfff4d0246c7294b032d55"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a06f85901afbfff4d0246c7294b032d55">remove</a> (const T *aObject)</td></tr>
<tr class="memdesc:a06f85901afbfff4d0246c7294b032d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an object from the array by specifying its address.  <a href="#a06f85901afbfff4d0246c7294b032d55">More...</a><br /></td></tr>
<tr class="separator:a06f85901afbfff4d0246c7294b032d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac109edf8d541f7d8f42c4d99a2f47a2f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#ac109edf8d541f7d8f42c4d99a2f47a2f">clearAndDestroy</a> ()</td></tr>
<tr class="separator:ac109edf8d541f7d8f42c4d99a2f47a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeced14b2425baebc463132a3e1caf22d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#aeced14b2425baebc463132a3e1caf22d">set</a> (int aIndex, T *aObject, bool preserveGroups=false)</td></tr>
<tr class="memdesc:aeced14b2425baebc463132a3e1caf22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the object at a specified index.  <a href="#aeced14b2425baebc463132a3e1caf22d">More...</a><br /></td></tr>
<tr class="separator:aeced14b2425baebc463132a3e1caf22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b8e86efd0f9a96724e92a6f742921c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a14b8e86efd0f9a96724e92a6f742921c">set</a> (int aIndex, const T &amp;aObject, bool preserveGroups=false)</td></tr>
<tr class="memdesc:a14b8e86efd0f9a96724e92a6f742921c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the object at a specified index.  <a href="#a14b8e86efd0f9a96724e92a6f742921c">More...</a><br /></td></tr>
<tr class="separator:a14b8e86efd0f9a96724e92a6f742921c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7891e577842d2e982dd2dd93deffece"><td class="memItemLeft" align="right" valign="top">virtual T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#ae7891e577842d2e982dd2dd93deffece">get</a> (int aIndex) const </td></tr>
<tr class="memdesc:ae7891e577842d2e982dd2dd93deffece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the value at a specified array index.  <a href="#ae7891e577842d2e982dd2dd93deffece">More...</a><br /></td></tr>
<tr class="separator:ae7891e577842d2e982dd2dd93deffece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caa97b3acc0b5d00ef40e4ce927cc13"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a3caa97b3acc0b5d00ef40e4ce927cc13">get</a> (const std::string &amp;aName)</td></tr>
<tr class="memdesc:a3caa97b3acc0b5d00ef40e4ce927cc13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first object that has a specified name.  <a href="#a3caa97b3acc0b5d00ef40e4ce927cc13">More...</a><br /></td></tr>
<tr class="separator:a3caa97b3acc0b5d00ef40e4ce927cc13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefaeeb2fc0f5cf29d0ee202bd840008b"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#aefaeeb2fc0f5cf29d0ee202bd840008b">get</a> (const std::string &amp;aName) const </td></tr>
<tr class="separator:aefaeeb2fc0f5cf29d0ee202bd840008b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c7a9cc403770e3d8384a511cd9c16a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#af3c7a9cc403770e3d8384a511cd9c16a">contains</a> (const std::string &amp;aName) const </td></tr>
<tr class="memdesc:af3c7a9cc403770e3d8384a511cd9c16a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether this <a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> contains any object with the specified name.  <a href="#af3c7a9cc403770e3d8384a511cd9c16a">More...</a><br /></td></tr>
<tr class="separator:af3c7a9cc403770e3d8384a511cd9c16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f74c3a23031cb976ca1c60bcd697a65"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a0f74c3a23031cb976ca1c60bcd697a65">getNames</a> (<a class="el" href="classOpenSim_1_1Array.html">OpenSim::Array</a>&lt; std::string &gt; &amp;rNames) const </td></tr>
<tr class="memdesc:a0f74c3a23031cb976ca1c60bcd697a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get names of objects in the set.  <a href="#a0f74c3a23031cb976ca1c60bcd697a65">More...</a><br /></td></tr>
<tr class="separator:a0f74c3a23031cb976ca1c60bcd697a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a904231b130475747af09326c1a656a"><td class="memItemLeft" align="right" valign="top">virtual T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a3a904231b130475747af09326c1a656a">getLast</a> () const </td></tr>
<tr class="memdesc:a3a904231b130475747af09326c1a656a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the last value in the array.  <a href="#a3a904231b130475747af09326c1a656a">More...</a><br /></td></tr>
<tr class="separator:a3a904231b130475747af09326c1a656a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5343404f00ee2737bf0cf1a1ccf826"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#add5343404f00ee2737bf0cf1a1ccf826">searchBinary</a> (const T &amp;aObject, bool aFindFirst=false, int aLo=-1, int aHi=-1) const </td></tr>
<tr class="memdesc:add5343404f00ee2737bf0cf1a1ccf826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for the largest value in the array that is less than or equal to a specified value.  <a href="#add5343404f00ee2737bf0cf1a1ccf826">More...</a><br /></td></tr>
<tr class="separator:add5343404f00ee2737bf0cf1a1ccf826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ddf58b87c3fb1e5a9dd837c222dd24"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a57ddf58b87c3fb1e5a9dd837c222dd24">getNumGroups</a> () const </td></tr>
<tr class="memdesc:a57ddf58b87c3fb1e5a9dd837c222dd24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of groups.  <a href="#a57ddf58b87c3fb1e5a9dd837c222dd24">More...</a><br /></td></tr>
<tr class="separator:a57ddf58b87c3fb1e5a9dd837c222dd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1a7526e94a761cf4f384ee1525777e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a6d1a7526e94a761cf4f384ee1525777e">addGroup</a> (const std::string &amp;aGroupName)</td></tr>
<tr class="memdesc:a6d1a7526e94a761cf4f384ee1525777e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an empty group to the set.  <a href="#a6d1a7526e94a761cf4f384ee1525777e">More...</a><br /></td></tr>
<tr class="separator:a6d1a7526e94a761cf4f384ee1525777e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55ad59a5acc97cf9f37b43d91be7328"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#aa55ad59a5acc97cf9f37b43d91be7328">removeGroup</a> (const std::string &amp;aGroupName)</td></tr>
<tr class="memdesc:aa55ad59a5acc97cf9f37b43d91be7328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a group from the set.  <a href="#aa55ad59a5acc97cf9f37b43d91be7328">More...</a><br /></td></tr>
<tr class="separator:aa55ad59a5acc97cf9f37b43d91be7328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1cff99c57f3c5f5b4001949b6e87f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#ace1cff99c57f3c5f5b4001949b6e87f1">renameGroup</a> (const std::string &amp;oldGroupName, const std::string &amp;newGroupName)</td></tr>
<tr class="memdesc:ace1cff99c57f3c5f5b4001949b6e87f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename a group.  <a href="#ace1cff99c57f3c5f5b4001949b6e87f1">More...</a><br /></td></tr>
<tr class="separator:ace1cff99c57f3c5f5b4001949b6e87f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac414dd319012df21c59658d034550f98"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#ac414dd319012df21c59658d034550f98">addObjectToGroup</a> (const std::string &amp;aGroupName, const std::string &amp;aObjectName)</td></tr>
<tr class="memdesc:ac414dd319012df21c59658d034550f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an object to a group.  <a href="#ac414dd319012df21c59658d034550f98">More...</a><br /></td></tr>
<tr class="separator:ac414dd319012df21c59658d034550f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3111fa277cdd017eafb059f39df2fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#abe3111fa277cdd017eafb059f39df2fa">getGroupNames</a> (<a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; std::string &gt; &amp;rGroupNames) const </td></tr>
<tr class="memdesc:abe3111fa277cdd017eafb059f39df2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get names of all groups.  <a href="#abe3111fa277cdd017eafb059f39df2fa">More...</a><br /></td></tr>
<tr class="separator:abe3111fa277cdd017eafb059f39df2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e2bbd1c70b5c20678faee246fa305b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOpenSim_1_1ObjectGroup.html">ObjectGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#af9e2bbd1c70b5c20678faee246fa305b">getGroup</a> (const std::string &amp;aGroupName) const </td></tr>
<tr class="memdesc:af9e2bbd1c70b5c20678faee246fa305b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a group by name.  <a href="#af9e2bbd1c70b5c20678faee246fa305b">More...</a><br /></td></tr>
<tr class="separator:af9e2bbd1c70b5c20678faee246fa305b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce16c4666f3fe8060adc852b4f93ca9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOpenSim_1_1ObjectGroup.html">ObjectGroup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a9ce16c4666f3fe8060adc852b4f93ca9">getGroup</a> (int aIndex) const </td></tr>
<tr class="memdesc:a9ce16c4666f3fe8060adc852b4f93ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a group by index.  <a href="#a9ce16c4666f3fe8060adc852b4f93ca9">More...</a><br /></td></tr>
<tr class="separator:a9ce16c4666f3fe8060adc852b4f93ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Auto-generated functions</h2></td></tr>
<tr class="memitem:a9ae52e7611579e4964a52b9d544532f2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOpenSim_1_1Set.html">Set</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a9ae52e7611579e4964a52b9d544532f2">safeDownCast</a> (<a class="el" href="classOpenSim_1_1Object.html">OpenSim::Object</a> *obj)</td></tr>
<tr class="memdesc:a9ae52e7611579e4964a52b9d544532f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">For use in MATLAB and Python to access the concrete class.  <a href="#a9ae52e7611579e4964a52b9d544532f2">More...</a><br /></td></tr>
<tr class="separator:a9ae52e7611579e4964a52b9d544532f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dee1ab9c02b9a496faa088de9764297"><td class="memItemLeft" align="right" valign="top">static const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a2dee1ab9c02b9a496faa088de9764297">getClassName</a> ()</td></tr>
<tr class="memdesc:a2dee1ab9c02b9a496faa088de9764297"><td class="mdescLeft">&#160;</td><td class="mdescRight">This returns "Set_&lt;T&gt;_".  <a href="#a2dee1ab9c02b9a496faa088de9764297">More...</a><br /></td></tr>
<tr class="separator:a2dee1ab9c02b9a496faa088de9764297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d051ec84036f76af430f03d14e53644"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1Set.html">Set</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#a5d051ec84036f76af430f03d14e53644">clone</a> () const  override</td></tr>
<tr class="separator:a5d051ec84036f76af430f03d14e53644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2df597a9004ec732627bf20ca8f7827"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Set.html#ad2df597a9004ec732627bf20ca8f7827">getConcreteClassName</a> () const  override</td></tr>
<tr class="separator:ad2df597a9004ec732627bf20ca8f7827"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description </h2>
<div class="textblock"><h3>template&lt;class T, class C = Object&gt;<br />
class OpenSim::Set&lt; T, C &gt;</h3>

<p>A class for holding a set of pointers to objects. </p>
<p>It is derived from base class C and is implemented as a wrapper around template class ArrayPtrs&lt;T&gt;.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOpenSim_1_1ArrayPtrs.html">ArrayPtrs</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Frank C. Anderson </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a608e97adc15002fcdaec6736d0512500"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::~<a class="el" href="classOpenSim_1_1Set.html">Set</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a class="anchor" id="abca0e3a7e5691d3df7c5476ee676019b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::<a class="el" href="classOpenSim_1_1Set.html">Set</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="a46f3485a26c614942c5b004761c2f1fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::<a class="el" href="classOpenSim_1_1Set.html">Set</a> </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>aFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aUpdateFromXMLNode</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aFileName</td><td>Name of the file. </td></tr>
    <tr><td class="paramname">aUpdateFromXMLNode</td><td>Whether to update from XML. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adf8721e5e16a595e9894c2ae97aeb8e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::<a class="el" href="classOpenSim_1_1Set.html">Set</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Set.html">Set</a>&lt; T, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSet</td><td><a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6d1a7526e94a761cf4f384ee1525777e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::addGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>aGroupName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an empty group to the set. </p>

</div>
</div>
<a class="anchor" id="ac414dd319012df21c59658d034550f98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::addObjectToGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>aGroupName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>aObjectName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an object to a group. </p>

</div>
</div>
<a class="anchor" id="a39d22c0e373cd80a65bfa01c1f20a6a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::adoptAndAppend </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>aObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append to the array, and adopt passed in pointer. </p>
<p>A copy is NOT made of the specified object. If <a class="el" href="classOpenSim_1_1Set.html#ac97d610cbb9f8ece390d7e849ee7cc72" title="Get whether or not this array owns the memory pointed to by the pointers in its array. ">getMemoryOwner()</a> is true, this <a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> takes over ownership of the object and deletes it when the <a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> itself is deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aObject</td><td><a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> to be appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the append was successful, false otherwise. </dd></dl>

<p>Referenced by <a class="el" href="classOpenSim_1_1ModelScaler.html#a0f2b02ca825bfb3ac1264d0c1c5c6a49">OpenSim::ModelScaler::addMeasurement()</a>, <a class="el" href="classOpenSim_1_1ModelScaler.html#a702f2a80869a53c9d2045a95ca158f4c">OpenSim::ModelScaler::addScale()</a>, and <a class="el" href="classOpenSim_1_1Set.html#a2e6704c1f65f94f1fd251577cf411d5c">OpenSim::Set&lt; Force, ModelComponent &gt;::cloneAndAppend()</a>.</p>

</div>
</div>
<a class="anchor" id="ac109edf8d541f7d8f42c4d99a2f47a2f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::clearAndDestroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d051ec84036f76af430f03d14e53644"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Set.html">Set</a>* <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classOpenSim_1_1ModelComponentSet.html#a4f05a809ef6a78a2adec2ab6670b31ca">OpenSim::ModelComponentSet&lt; ExternalForce &gt;</a>, <a class="el" href="classOpenSim_1_1ModelComponentSet.html#a4f05a809ef6a78a2adec2ab6670b31ca">OpenSim::ModelComponentSet&lt; ContactGeometry &gt;</a>, <a class="el" href="classOpenSim_1_1ModelComponentSet.html#a4f05a809ef6a78a2adec2ab6670b31ca">OpenSim::ModelComponentSet&lt; WrapObject &gt;</a>, <a class="el" href="classOpenSim_1_1ModelComponentSet.html#a4f05a809ef6a78a2adec2ab6670b31ca">OpenSim::ModelComponentSet&lt; Force &gt;</a>, <a class="el" href="classOpenSim_1_1ModelComponentSet.html#a4f05a809ef6a78a2adec2ab6670b31ca">OpenSim::ModelComponentSet&lt; Joint &gt;</a>, <a class="el" href="classOpenSim_1_1ModelComponentSet.html#a4f05a809ef6a78a2adec2ab6670b31ca">OpenSim::ModelComponentSet&lt; Probe &gt;</a>, <a class="el" href="classOpenSim_1_1ModelComponentSet.html#a4f05a809ef6a78a2adec2ab6670b31ca">OpenSim::ModelComponentSet&lt; Controller &gt;</a>, <a class="el" href="classOpenSim_1_1ModelComponentSet.html#a4f05a809ef6a78a2adec2ab6670b31ca">OpenSim::ModelComponentSet&lt; ModelComponent &gt;</a>, <a class="el" href="classOpenSim_1_1ModelComponentSet.html#a4f05a809ef6a78a2adec2ab6670b31ca">OpenSim::ModelComponentSet&lt; Marker &gt;</a>, <a class="el" href="classOpenSim_1_1ModelComponentSet.html#a4f05a809ef6a78a2adec2ab6670b31ca">OpenSim::ModelComponentSet&lt; Body &gt;</a>, and <a class="el" href="classOpenSim_1_1ModelComponentSet.html#a4f05a809ef6a78a2adec2ab6670b31ca">OpenSim::ModelComponentSet&lt; Constraint &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2e6704c1f65f94f1fd251577cf411d5c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::cloneAndAppend </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>aObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cloneAndAppend creates a clone of the passed in object and appends the clone to the array. </p>
<p>The original object is unaffected and is not associated with the <a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a>. The clone is created using the method <a class="el" href="classOpenSim_1_1Set.html#a5d051ec84036f76af430f03d14e53644">clone()</a> available to <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">OpenSim::Object</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aObject</td><td><a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> whose clone is to be appended. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the append was successful, false otherwise. </dd></dl>

<p>Referenced by <a class="el" href="classOpenSim_1_1IKTaskSet.html#a06588049529588e09fe6cfc29c9a6744">OpenSim::IKTaskSet::createMarkerWeightSet()</a>.</p>

</div>
</div>
<a class="anchor" id="a1ddd97e9cf8a4b759e2e46f8d97e136c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::computeNewCapacity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aMinCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>rNewCapacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a new capacity that is at least as large as a specified minimum capacity; this method does not change the capacity, it simply computes a new recommended capacity. </p>
<p>If the capacity increment is negative, the current capacity is doubled until the computed capacity is greater than or equal to the specified minimum capacity. If the capacity increment is positive, the current capacity increments by this amount until the computed capacity is greater than or equal to the specified minimum capacity. If the capacity increment is zero, the computed capacity is set to the current capacity and false is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rNewCapacity</td><td>New computed capacity. </td></tr>
    <tr><td class="paramname">aMinCapacity</td><td>Minimum new computed capacity. The computed capacity is incremented until it is at least as large as aMinCapacity, assuming the capacity increment is not zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the new capacity was increased, false otherwise (i.e., if the capacity increment is set to 0). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOpenSim_1_1Set.html#ab9a9810443f5b1600316a84615838fe5" title="Set the amount by which the capacity is increased when the capacity of of the array in exceeded...">setCapacityIncrement()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af3c7a9cc403770e3d8384a511cd9c16a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>aName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether this <a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> contains any object with the specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aName</td><td>Name of the desired object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the object exists </dd></dl>

<p>Referenced by <a class="el" href="classOpenSim_1_1Set.html#a04be479fb15d7493ec279e8141537d64">OpenSim::Set&lt; Force, ModelComponent &gt;::getGroupNamesContaining()</a>.</p>

</div>
</div>
<a class="anchor" id="ac0db50c56a783c3ad288e060528b89bd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::ensureCapacity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure that the capacity of this array is at least the specified amount. </p>
<p>The newly allocated array elements are initialized to NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aCapacity</td><td>Desired capacity. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the capacity was successfully obtained, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7891e577842d2e982dd2dd93deffece"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T&amp; <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the value at a specified array index. </p>
<p>If the index is negative or passed the end of the array, an exception is thrown.</p>
<p>For faster execution, the array elements can be accessed through the overloaded operator[], which does no bounds checking.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIndex</td><td>Index of the desired array element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the array element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classOpenSim_1_1Exception.html" title="A class for basic exception functionality. ">Exception</a></td><td>if (aIndex&lt;0)||(aIndex&gt;=_size) or if the pointer at aIndex is NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>operator[]. </dd></dl>

</div>
</div>
<a class="anchor" id="a3caa97b3acc0b5d00ef40e4ce927cc13"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>aName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first object that has a specified name. </p>
<p>If the array doesn't contain an object of the specified name, an exception is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aName</td><td>Name of the desired object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classOpenSim_1_1Exception.html" title="A class for basic exception functionality. ">Exception</a></td><td>if no such object exists. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOpenSim_1_1Set.html#a7c13fe73297891a888ffd954f2a831f7" title="Get the index of an object. ">getIndex()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aefaeeb2fc0f5cf29d0ee202bd840008b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>aName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a13cba82725570aa40ca1cc97a1697328"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::getCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the capacity of this storage instance. </p>

</div>
</div>
<a class="anchor" id="a3299aa1bf89c85e7bce9fa219034e4c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::getCapacityIncrement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the amount by which the capacity is increased. </p>

</div>
</div>
<a class="anchor" id="a2dee1ab9c02b9a496faa088de9764297"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::string&amp; <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::getClassName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This returns "Set_&lt;T&gt;_". </p>
<p>T is the template argument for this class. See <a class="el" href="classOpenSim_1_1Set.html#ad2df597a9004ec732627bf20ca8f7827">getConcreteClassName()</a> if you want the class name of the underlying concrete object instead. </p>

</div>
</div>
<a class="anchor" id="ad2df597a9004ec732627bf20ca8f7827"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::getConcreteClassName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classOpenSim_1_1ModelComponentSet.html#aba7170fd7cff964fc3cfc4791f816afc">OpenSim::ModelComponentSet&lt; ExternalForce &gt;</a>, <a class="el" href="classOpenSim_1_1ModelComponentSet.html#aba7170fd7cff964fc3cfc4791f816afc">OpenSim::ModelComponentSet&lt; ContactGeometry &gt;</a>, <a class="el" href="classOpenSim_1_1ModelComponentSet.html#aba7170fd7cff964fc3cfc4791f816afc">OpenSim::ModelComponentSet&lt; WrapObject &gt;</a>, <a class="el" href="classOpenSim_1_1ModelComponentSet.html#aba7170fd7cff964fc3cfc4791f816afc">OpenSim::ModelComponentSet&lt; Force &gt;</a>, <a class="el" href="classOpenSim_1_1ModelComponentSet.html#aba7170fd7cff964fc3cfc4791f816afc">OpenSim::ModelComponentSet&lt; Joint &gt;</a>, <a class="el" href="classOpenSim_1_1ModelComponentSet.html#aba7170fd7cff964fc3cfc4791f816afc">OpenSim::ModelComponentSet&lt; Probe &gt;</a>, <a class="el" href="classOpenSim_1_1ModelComponentSet.html#aba7170fd7cff964fc3cfc4791f816afc">OpenSim::ModelComponentSet&lt; Controller &gt;</a>, <a class="el" href="classOpenSim_1_1ModelComponentSet.html#aba7170fd7cff964fc3cfc4791f816afc">OpenSim::ModelComponentSet&lt; ModelComponent &gt;</a>, <a class="el" href="classOpenSim_1_1ModelComponentSet.html#aba7170fd7cff964fc3cfc4791f816afc">OpenSim::ModelComponentSet&lt; Marker &gt;</a>, <a class="el" href="classOpenSim_1_1ModelComponentSet.html#aba7170fd7cff964fc3cfc4791f816afc">OpenSim::ModelComponentSet&lt; Body &gt;</a>, and <a class="el" href="classOpenSim_1_1ModelComponentSet.html#aba7170fd7cff964fc3cfc4791f816afc">OpenSim::ModelComponentSet&lt; Constraint &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af9e2bbd1c70b5c20678faee246fa305b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOpenSim_1_1ObjectGroup.html">ObjectGroup</a>* <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::getGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>aGroupName</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a group by name. </p>

</div>
</div>
<a class="anchor" id="a9ce16c4666f3fe8060adc852b4f93ca9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOpenSim_1_1ObjectGroup.html">ObjectGroup</a>* <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::getGroup </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a group by index. </p>

</div>
</div>
<a class="anchor" id="abe3111fa277cdd017eafb059f39df2fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::getGroupNames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>rGroupNames</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get names of all groups. </p>

</div>
</div>
<a class="anchor" id="a04be479fb15d7493ec279e8141537d64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::getGroupNamesContaining </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>aObjectName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Array.html">Array</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>rGroupNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get names of groups containing a given object. </p>

</div>
</div>
<a class="anchor" id="a7c13fe73297891a888ffd954f2a831f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::getIndex </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>aObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aStartIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index of an object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aObject</td><td>Address of the object whose index is sought. </td></tr>
    <tr><td class="paramname">aStartIndex</td><td>Index at which to start searching. If the object is not found at or following aStartIndex, the array is searched from its beginning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the object with the address aObject. If no such object exists in the array, -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ae3ddd31a4131d7c7805f9858614ba25f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::getIndex </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>aName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aStartIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index of an object by specifying its name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aName</td><td>Name of the object whose index is sought. </td></tr>
    <tr><td class="paramname">aStartIndex</td><td>Index at which to start searching. If the object is not found at or following aStartIndex, the array is searched from its beginning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the object named aName. If no such object exists in the array, -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a904231b130475747af09326c1a656a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual T* <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::getLast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the last value in the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Last value in the array. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classOpenSim_1_1Exception.html" title="A class for basic exception functionality. ">Exception</a></td><td>if the array is empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac97d610cbb9f8ece390d7e849ee7cc72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::getMemoryOwner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get whether or not this array owns the memory pointed to by the pointers in its array. </p>
<p>If the array is set to own the memory pointed to by its pointers, this array issues deletes for all these pointers upon the array's destruction. If not, this array does not issue deletes.</p>
<dl class="section return"><dt>Returns</dt><dd>True if this array owns the memory; false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f74c3a23031cb976ca1c60bcd697a65"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::getNames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Array.html">OpenSim::Array</a>&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>rNames</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get names of objects in the set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rNames</td><td><a class="el" href="classOpenSim_1_1Array.html" title="A class for storing an array of values of type T. ">Array</a> of names. The names are appended to rNames, so it is permissible to send in an non-empty array; the names in the set will simply be appended to the array sent in. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a57ddf58b87c3fb1e5a9dd837c222dd24"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::getNumGroups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of groups. </p>

</div>
</div>
<a class="anchor" id="a129d0a6e121754ca38cb28afdd343a2d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of the array. </dd></dl>

<p>Referenced by <a class="el" href="classOpenSim_1_1ProbeReporter.html#afec55d83071ec14478ed470642b64412">OpenSim::ProbeReporter::disableIntegrationOnlyProbes()</a>, <a class="el" href="classOpenSim_1_1Measurement.html#a602b62a426ee8661ccecf43535d2666b">OpenSim::Measurement::getNumMarkerPairs()</a>, and <a class="el" href="classOpenSim_1_1StateTrackingTask.html#a3603df557f57593bbc5ebfd3f951eb93">OpenSim::StateTrackingTask::getTaskErrorGradient()</a>.</p>

</div>
</div>
<a class="anchor" id="adf1da111571bb1f156da8ab169181a48"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>aObject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an object into the array at a specified index. </p>
<p>A copy of the specified object is NOT made. If <a class="el" href="classOpenSim_1_1Set.html#ac97d610cbb9f8ece390d7e849ee7cc72" title="Get whether or not this array owns the memory pointed to by the pointers in its array. ">getMemoryOwner()</a> is true, this <a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> takes over ownership of the object and deletes it when the <a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> itself is deleted.</p>
<p>This method is relatively computationally costly since many of the array elements may need to be shifted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aObject</td><td><a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> to be inserted. </td></tr>
    <tr><td class="paramname">aIndex</td><td>Index at which to insert the new object. All current elements from aIndex to the end of the array are shifted one place in the direction of the end of the array. The specified index must be less than or equal to the size of the array. Note that if aIndex is equal to the size of the array, the insertion is equivalent to an append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the insertion was successful, false otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classOpenSim_1_1ForceSet.html#ac1b21274343eb06cfcf920708621bcfd">OpenSim::ForceSet</a>.</p>

<p>Referenced by <a class="el" href="classOpenSim_1_1Set.html#af79a11b57529978ce78c9dc28771bfe2">OpenSim::Set&lt; Force, ModelComponent &gt;::insert()</a>.</p>

</div>
</div>
<a class="anchor" id="af79a11b57529978ce78c9dc28771bfe2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>aObject</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an object into the array at a specified index. </p>
<p>A copy is made of the object and added to the <a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a>. The original object is unaffected.</p>
<p>This method is relatively computationally costly since many of the array elements may need to be shifted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aObject</td><td><a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> to be inserted. </td></tr>
    <tr><td class="paramname">aIndex</td><td>Index at which to insert the new object. All current elements from aIndex to the end of the array are shifted one place in the direction of the end of the array. The specified index must be less than or equal to the size of the array. Note that if aIndex is equal to the size of the array, the insertion is equivalent to an append. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the insertion was successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a06b854682659a2a4dbdff82cc7d5a553"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Set.html">Set</a>&lt;T,C&gt;&amp; <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Set.html">Set</a>&lt; T, C &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign this set to another set. </p>
<p>This operator makes a complete copy of the specified set; all member variables and objects in the set are copied. Because all objects are copied, this set takes ownership of the newly allocated objects (i.e., _memoryOwner is set to true. So, the result is two independent, identical sets, with the possible exception of the _memoryOwner flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>The <a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> to be copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this set. </dd></dl>

<p>Referenced by <a class="el" href="classOpenSim_1_1IKTaskSet.html#add0ea0f7a606f1dbe6ad3956a54abbd5">OpenSim::IKTaskSet::operator=()</a>.</p>

</div>
</div>
<a class="anchor" id="abc219f936f53dfed9c78c97dbc781736"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to the set object at a specified index. </p>
<p>This operator is intended for accessing set objects with as little overhead as possible, so no error checking is performed. The caller must make sure the specified index is within the bounds of the array. If error checking is desired, use ArrayPtrs::get().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIndex</td><td>Index of the desired element (0 &lt;= aIndex &lt; _size). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the array element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classOpenSim_1_1Exception.html" title="A class for basic exception functionality. ">Exception</a></td><td>if a NULL pointer is encountered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classOpenSim_1_1Set.html#ae7891e577842d2e982dd2dd93deffece" title="Get the value at a specified array index. ">get()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2a403c4fee4095464d6e9d92aaa512c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an object from the array at a specified index. </p>
<p>If this set is set as the memory owner, the object is deleted when it is removed.</p>
<p>This method is relatively computationally costly since many of the array elements may need to be shifted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIndex</td><td>Index of the value to remove. All elements from aIndex to the end of the array are shifted one place toward the beginning of the array. If aIndex is less than 0 or greater than or equal to the current size of the array, no element is removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the removal was successful, false otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classOpenSim_1_1ForceSet.html#ac430dbb088c7c64f9119a82feec7a5c3">OpenSim::ForceSet</a>.</p>

</div>
</div>
<a class="anchor" id="a06f85901afbfff4d0246c7294b032d55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>aObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove an object from the array by specifying its address. </p>
<p>The object is deleted when it is removed.</p>
<p>This method is relatively computationally costly since many of the array elements may need to be shifted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aObject</td><td>Pointer to the object to be removed. If an object with the specified address is not found, no action is taken. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the removal was successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="aa55ad59a5acc97cf9f37b43d91be7328"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::removeGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>aGroupName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a group from the set. </p>
<p>Elements are not removed. </p>

</div>
</div>
<a class="anchor" id="ace1cff99c57f3c5f5b4001949b6e87f1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::renameGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>oldGroupName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>newGroupName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename a group. </p>

</div>
</div>
<a class="anchor" id="a9ae52e7611579e4964a52b9d544532f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOpenSim_1_1Set.html">Set</a>* <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::safeDownCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Object.html">OpenSim::Object</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For use in MATLAB and Python to access the concrete class. </p>
<p>Example: <code>cObj = Set.safeDownCast(obj)</code>. This is equivalent to <code>dynamic_cast&lt;Set*&gt;(obj)</code> in C++. </p>

</div>
</div>
<a class="anchor" id="add5343404f00ee2737bf0cf1a1ccf826"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::searchBinary </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>aObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aFindFirst</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aLo</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aHi</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for the largest value in the array that is less than or equal to a specified value. </p>
<p>If there is more than one element with this largest value, the index of the first of these elements can optionally be found, but this can be up to twice as costly.</p>
<p>This method assumes that the array element values monotonically increase as the array index increases. Note that monotonically increase means never decrease, so it is permissible for adjacent elements to have the same value.</p>
<p>A binary search is performed (i.e., the array is repeatedly subdivided into two bins one of which must contain the specified until the appropriate element is identified), so the performance of this method is approximately ln(n), where n is the size of the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aObject</td><td>Value to which the array elements are compared. </td></tr>
    <tr><td class="paramname">aFindFirst</td><td>If true, find the first element that satisfies the search. If false, the index of any element that satisfies the search can be returned- which index will be returned depends on the length of the array and is therefore somewhat arbitrary. By default, this flag is false. </td></tr>
    <tr><td class="paramname">aLo</td><td>Lowest array index to consider in the search. </td></tr>
    <tr><td class="paramname">aHi</td><td>Highest array index to consider in the search. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Index of the array element that has the largest value that is less than or equal to aValue. If there is more than one such elements with the same value and aFindFirst is set to true, the index of the first of these elements is returned. If an error is encountered (e.g., the array is empty), or the array contains no element that is less than or equal to aValue, -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="aeced14b2425baebc463132a3e1caf22d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>aObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserveGroups</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the object at a specified index. </p>
<p>A copy of the object is NOT made. If <a class="el" href="classOpenSim_1_1Set.html#ac97d610cbb9f8ece390d7e849ee7cc72" title="Get whether or not this array owns the memory pointed to by the pointers in its array. ">getMemoryOwner()</a> is true, this <a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> takes over ownership of the object and deletes it when the <a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> itself is deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIndex</td><td>Index of the array element to be set. aIndex must be greater than zero and less than or equal to the size of the array. Note that if aIndex is equal to the size of the array, the set is equivalent to an append. </td></tr>
    <tr><td class="paramname">aObject</td><td><a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> to be set. </td></tr>
    <tr><td class="paramname">preserveGroups</td><td>If true, the new object will be added to the groups that the object it replaces belonged to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the set was successful, false otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="classOpenSim_1_1ForceSet.html#a8edb4dc9184c4bb5a54cbe32acb7adb0">OpenSim::ForceSet</a>.</p>

</div>
</div>
<a class="anchor" id="a14b8e86efd0f9a96724e92a6f742921c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>aObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserveGroups</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the object at a specified index. </p>
<p>A copy is made of the object and added to the <a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a>. The original object is unaffected.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIndex</td><td>Index of the array element to be set. aIndex must be greater than zero and less than or equal to the size of the array. Note that if aIndex is equal to the size of the array, the set is equivalent to an append. </td></tr>
    <tr><td class="paramname">aObject</td><td><a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> to be set. </td></tr>
    <tr><td class="paramname">preserveGroups</td><td>If true, the new object will be added to the groups that the object it replaces belonged to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the set was successful, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9a9810443f5b1600316a84615838fe5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::setCapacityIncrement </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aIncrement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the amount by which the capacity is increased when the capacity of of the array in exceeded. </p>
<p>If the specified increment is negative or this method is called with no argument, the capacity is set to double whenever the capacity is exceeded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aIncrement</td><td>Desired capacity increment. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a532132c98808305e0e5ec179a5368008"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::setMemoryOwner </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>aTrueFalse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set whether or not this <a class="el" href="classOpenSim_1_1Set.html" title="A class for holding a set of pointers to objects. ">Set</a> owns the memory pointed to by the pointers it holds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aTrueFalse</td><td>If true, all the memory associated with each of the pointers in this array are deleted upon the array's destruction. If false, deletes are not issued for each of the pointers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a092511a68bb319cbf647b64b0e35feee"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::setSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>aSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the size of the array. </p>
<p>This method can be used only to decrease the size of the array. If the size of an array is decreased, all objects in the array that become invalid as a result of the decrease are deleted.</p>
<p>Note that the size of an array is different than its capacity. The size indicates how many valid elements are stored in an array. The capacity indicates how much the size of the array can be increased without allocated more memory. At all times size &lt;= capacity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aSize</td><td>Desired size of the array. The size must be greater than or equal to zero and less than or equal to the current size of the array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the requested size change was carried out, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a40ef09b96382c20ba4e220a2541f2bda"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::setupGroups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setup groups (match group member names to set members). </p>

</div>
</div>
<a class="anchor" id="a5a39d7a869b76794fb11cf41439014c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class C = Object&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Set.html">OpenSim::Set</a>&lt; T, C &gt;::trim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Trim the capacity of this array so that it is one larger than the size of this array. </p>
<p>This is useful for reducing the amount of memory used by this array. This capacity is kept at one larger than the size so that, for example, an array of characters can be treated as a NULL terminated string. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>OpenSim/Common/Set.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceOpenSim.html">OpenSim</a></li><li class="navelem"><a class="el" href="classOpenSim_1_1Set.html">Set</a></li>
    <li class="footer">Generated on Thu Feb 6 2020 19:08:10 for API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
