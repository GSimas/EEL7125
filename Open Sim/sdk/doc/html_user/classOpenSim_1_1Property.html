<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>API: OpenSim::Property&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen_user.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="OpenSimLogoWhiteHorizontal_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">API
   &#160;<span id="projectnumber">4.1</span>
   </div>
   <div id="projectbrief">For MATLAB, Python, Java, and C++ users</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Class&#160;Groups</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List&#160;</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classOpenSim_1_1Property.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="classOpenSim_1_1Property-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">OpenSim::Property&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T.  
 <a href="classOpenSim_1_1Property.html#details">More...</a></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for OpenSim::Property&lt; T &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="classOpenSim_1_1Property.png" usemap="#OpenSim::Property_3C_20T_20_3E_map" alt=""/>
  <map id="OpenSim::Property_3C_20T_20_3E_map" name="OpenSim::Property&lt; T &gt;_map">
<area href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va..." alt="OpenSim::AbstractProperty" shape="rect" coords="0,0,165,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a04c7dbc509b6247209320f4cffa3e335"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1Property.html">Property</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a04c7dbc509b6247209320f4cffa3e335">clone</a> () const  override=0</td></tr>
<tr class="memdesc:a04c7dbc509b6247209320f4cffa3e335"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new, deep copy (clone) of this concrete property and return a pointer to the heap space.  <a href="#a04c7dbc509b6247209320f4cffa3e335">More...</a><br /></td></tr>
<tr class="separator:a04c7dbc509b6247209320f4cffa3e335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bc4edc7b1102885371bbeece620f43"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#aa7bc4edc7b1102885371bbeece620f43">getTypeName</a> () const  override final</td></tr>
<tr class="memdesc:aa7bc4edc7b1102885371bbeece620f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use <a class="el" href="structOpenSim_1_1Property_1_1TypeHelper.html" title="This is the generic definition of Property::TypeHelper to be used whenever T does not have a speciali...">TypeHelper</a>'s <a class="el" href="classOpenSim_1_1Property.html#aa7bc4edc7b1102885371bbeece620f43" title="Use TypeHelper&#39;s getTypeName() to satisfy this pure virtual. ">getTypeName()</a> to satisfy this pure virtual.  <a href="#aa7bc4edc7b1102885371bbeece620f43">More...</a><br /></td></tr>
<tr class="separator:aa7bc4edc7b1102885371bbeece620f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e132b9552b6c2a9cc8f6a33576fcb1a"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a7e132b9552b6c2a9cc8f6a33576fcb1a">operator[]</a> (int i) const </td></tr>
<tr class="memdesc:a7e132b9552b6c2a9cc8f6a33576fcb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to one of the values in the value list.  <a href="#a7e132b9552b6c2a9cc8f6a33576fcb1a">More...</a><br /></td></tr>
<tr class="separator:a7e132b9552b6c2a9cc8f6a33576fcb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567d26efb726367aca90f2534b032352"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a567d26efb726367aca90f2534b032352">operator[]</a> (int i)</td></tr>
<tr class="memdesc:a567d26efb726367aca90f2534b032352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a writable reference to one of the values in the value list.  <a href="#a567d26efb726367aca90f2534b032352">More...</a><br /></td></tr>
<tr class="separator:a567d26efb726367aca90f2534b032352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c23999672ed5ec0d74d140a67e89ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1Property.html">Property</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#aa9c23999672ed5ec0d74d140a67e89ea">operator=</a> (const T &amp;value)</td></tr>
<tr class="memdesc:aa9c23999672ed5ec0d74d140a67e89ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment to a value of type T sets the value of this single-valued property to a copy of the supplied <em>value</em>; not allowed for a list property.  <a href="#aa9c23999672ed5ec0d74d140a67e89ea">More...</a><br /></td></tr>
<tr class="separator:aa9c23999672ed5ec0d74d140a67e89ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f1f6ba165cb5bd24cab98a22a8076c"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class Container&gt; </td></tr>
<tr class="memitem:af3f1f6ba165cb5bd24cab98a22a8076c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classOpenSim_1_1Property.html">Property</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#af3f1f6ba165cb5bd24cab98a22a8076c">operator=</a> (const Container&lt; T &gt; &amp;valueList)</td></tr>
<tr class="memdesc:af3f1f6ba165cb5bd24cab98a22a8076c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment to a container of values of type T sets the entire value list of this list property to a copy of the values in the container.  <a href="#af3f1f6ba165cb5bd24cab98a22a8076c">More...</a><br /></td></tr>
<tr class="separator:af3f1f6ba165cb5bd24cab98a22a8076c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8b68f9fa4cf67c5b9d681b4499d63e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a3a8b68f9fa4cf67c5b9d681b4499d63e">setValue</a> (int i, const T &amp;value)</td></tr>
<tr class="memdesc:a3a8b68f9fa4cf67c5b9d681b4499d63e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace the i'th value list element with a copy of the given <em>value</em>.  <a href="#a3a8b68f9fa4cf67c5b9d681b4499d63e">More...</a><br /></td></tr>
<tr class="separator:a3a8b68f9fa4cf67c5b9d681b4499d63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92e55af5a211a210900438d858a481a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#aa92e55af5a211a210900438d858a481a">setValue</a> (const T &amp;value)</td></tr>
<tr class="memdesc:aa92e55af5a211a210900438d858a481a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provide a new value for a single-valued property.  <a href="#aa92e55af5a211a210900438d858a481a">More...</a><br /></td></tr>
<tr class="separator:aa92e55af5a211a210900438d858a481a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00355490194329012905b3407917fe9e"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class Container&gt; </td></tr>
<tr class="memitem:a00355490194329012905b3407917fe9e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a00355490194329012905b3407917fe9e">setValue</a> (const Container&lt; T &gt; &amp;valueList)</td></tr>
<tr class="memdesc:a00355490194329012905b3407917fe9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment to a container of values of type T sets the entire value list of this list property to a copy of the values in the container.  <a href="#a00355490194329012905b3407917fe9e">More...</a><br /></td></tr>
<tr class="separator:a00355490194329012905b3407917fe9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e1ead8242e6c28a48c1a99b849ecfb"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a66e1ead8242e6c28a48c1a99b849ecfb">getValue</a> (int index=-1) const </td></tr>
<tr class="memdesc:a66e1ead8242e6c28a48c1a99b849ecfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the selected value from this property's value list.  <a href="#a66e1ead8242e6c28a48c1a99b849ecfb">More...</a><br /></td></tr>
<tr class="separator:a66e1ead8242e6c28a48c1a99b849ecfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae597340fa1da9385439bbebf91a6a92a"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#ae597340fa1da9385439bbebf91a6a92a">updValue</a> (int index=-1)</td></tr>
<tr class="memdesc:ae597340fa1da9385439bbebf91a6a92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to the selected value from this property's value list.  <a href="#ae597340fa1da9385439bbebf91a6a92a">More...</a><br /></td></tr>
<tr class="separator:ae597340fa1da9385439bbebf91a6a92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cebe3dfc74cb4f1d5158a4feb449e05"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a8cebe3dfc74cb4f1d5158a4feb449e05">appendValue</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a8cebe3dfc74cb4f1d5158a4feb449e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a copy of the supplied <em>value</em> to the end of this property's value list.  <a href="#a8cebe3dfc74cb4f1d5158a4feb449e05">More...</a><br /></td></tr>
<tr class="separator:a8cebe3dfc74cb4f1d5158a4feb449e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8d2992c9f493380aa3400a6f6ec9a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a7f8d2992c9f493380aa3400a6f6ec9a8">appendValue</a> (const T *value)</td></tr>
<tr class="memdesc:a7f8d2992c9f493380aa3400a6f6ec9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a <em>copy</em> of the supplied <em>value</em> to the end of this property's value list.  <a href="#a7f8d2992c9f493380aa3400a6f6ec9a8">More...</a><br /></td></tr>
<tr class="separator:a7f8d2992c9f493380aa3400a6f6ec9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f955ce364fd5c6a031263894a77c6a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a7f955ce364fd5c6a031263894a77c6a2">adoptAndAppendValue</a> (T *value)</td></tr>
<tr class="memdesc:a7f955ce364fd5c6a031263894a77c6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new value to the end of this property's value list, taking over ownership of the supplied heap-allocated object.  <a href="#a7f955ce364fd5c6a031263894a77c6a2">More...</a><br /></td></tr>
<tr class="separator:a7f955ce364fd5c6a031263894a77c6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9169673da96ab5c0da51048ef331f134"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a9169673da96ab5c0da51048ef331f134">findIndex</a> (const T &amp;value) const </td></tr>
<tr class="memdesc:a9169673da96ab5c0da51048ef331f134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the value list for an element that has the given <em>value</em> and return its index if found, otherwise -1.  <a href="#a9169673da96ab5c0da51048ef331f134">More...</a><br /></td></tr>
<tr class="separator:a9169673da96ab5c0da51048ef331f134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5557f6f0e504ab3e8360574019a500"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#aca5557f6f0e504ab3e8360574019a500">findIndexForName</a> (const SimTK::String &amp;name) const  =0</td></tr>
<tr class="memdesc:aca5557f6f0e504ab3e8360574019a500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return index of passed in name if the <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">Property</a> contains objects that are derived from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">OpenSim::Object</a>, and -1 if no such <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> is found.  <a href="#aca5557f6f0e504ab3e8360574019a500">More...</a><br /></td></tr>
<tr class="separator:aca5557f6f0e504ab3e8360574019a500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classOpenSim_1_1AbstractProperty"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classOpenSim_1_1AbstractProperty')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classOpenSim_1_1AbstractProperty.html">OpenSim::AbstractProperty</a></td></tr>
<tr class="memitem:a0685f52599efbdd68462babddd4859e4 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a0685f52599efbdd68462babddd4859e4">setAllowableListSize</a> (int aMin, int aMax)</td></tr>
<tr class="memdesc:a0685f52599efbdd68462babddd4859e4 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require that the number of values n in the value list of this property be in the range aMin &lt;= n &lt;= aMax.  <a href="#a0685f52599efbdd68462babddd4859e4">More...</a><br /></td></tr>
<tr class="separator:a0685f52599efbdd68462babddd4859e4 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c9f2020339f49a08a9a3a3a37adc5f inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a26c9f2020339f49a08a9a3a3a37adc5f">setAllowableListSize</a> (int aNum)</td></tr>
<tr class="memdesc:a26c9f2020339f49a08a9a3a3a37adc5f inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require that the number of values n in the value list of this property be exactly n=aNum values.  <a href="#a26c9f2020339f49a08a9a3a3a37adc5f">More...</a><br /></td></tr>
<tr class="separator:a26c9f2020339f49a08a9a3a3a37adc5f inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab21326774230e4921d6e912bbb1bb71 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#aab21326774230e4921d6e912bbb1bb71">~AbstractProperty</a> ()</td></tr>
<tr class="memdesc:aab21326774230e4921d6e912bbb1bb71 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return all heap space used by this property.  <a href="#aab21326774230e4921d6e912bbb1bb71">More...</a><br /></td></tr>
<tr class="separator:aab21326774230e4921d6e912bbb1bb71 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4743e1d3ce8f0dc41e6320e13041ac inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a5c4743e1d3ce8f0dc41e6320e13041ac">toString</a> () const  =0</td></tr>
<tr class="memdesc:a5c4743e1d3ce8f0dc41e6320e13041ac inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">For relatively simple types, return the current value of this property in a string suitable for displaying to a user in the GUI (i.e., this number may be rounded and not an exact representation of the actual value being used).  <a href="#a5c4743e1d3ce8f0dc41e6320e13041ac">More...</a><br /></td></tr>
<tr class="separator:a5c4743e1d3ce8f0dc41e6320e13041ac inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d31d4e4d2df0f3c2fe71d46845e4f13 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a0d31d4e4d2df0f3c2fe71d46845e4f13">toStringForDisplay</a> (const int precision) const </td></tr>
<tr class="memdesc:a0d31d4e4d2df0f3c2fe71d46845e4f13 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">For relatively simple types, return the current value of this property in a string suitable for displaying to a user in the GUI (i.e., this number may be rounded and not an exact representation of the actual value being used).  <a href="#a0d31d4e4d2df0f3c2fe71d46845e4f13">More...</a><br /></td></tr>
<tr class="separator:a0d31d4e4d2df0f3c2fe71d46845e4f13 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80471cf2036a18f722b01e972a2717f inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#af80471cf2036a18f722b01e972a2717f">isObjectProperty</a> () const  =0</td></tr>
<tr class="memdesc:af80471cf2036a18f722b01e972a2717f inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an "object property", meaning that its values are all concrete objects of types that ultimately derive from the OpenSim serializable base class <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>.  <a href="#af80471cf2036a18f722b01e972a2717f">More...</a><br /></td></tr>
<tr class="separator:af80471cf2036a18f722b01e972a2717f inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1e407bf29ddbc9683b4e4c69fe323c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a1d1e407bf29ddbc9683b4e4c69fe323c">isUnnamedProperty</a> () const  =0</td></tr>
<tr class="memdesc:a1d1e407bf29ddbc9683b4e4c69fe323c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">An unnamed property is a one-object property whose name was given as null or as the contained object's type tag.  <a href="#a1d1e407bf29ddbc9683b4e4c69fe323c">More...</a><br /></td></tr>
<tr class="separator:a1d1e407bf29ddbc9683b4e4c69fe323c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a801d683ef4f717be82244c1b59678d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a5a801d683ef4f717be82244c1b59678d">equals</a> (const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;other) const </td></tr>
<tr class="memdesc:a5a801d683ef4f717be82244c1b59678d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare this property with another one; this is primarily used for testing.  <a href="#a5a801d683ef4f717be82244c1b59678d">More...</a><br /></td></tr>
<tr class="separator:a5a801d683ef4f717be82244c1b59678d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2104fc45e1859ec3bf1d60982d2fdc36 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a2104fc45e1859ec3bf1d60982d2fdc36">isSamePropertyClass</a> (const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;other) const </td></tr>
<tr class="memdesc:a2104fc45e1859ec3bf1d60982d2fdc36 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the <em>other</em> property is an object of exactly the same concrete class as this one.  <a href="#a2104fc45e1859ec3bf1d60982d2fdc36">More...</a><br /></td></tr>
<tr class="separator:a2104fc45e1859ec3bf1d60982d2fdc36 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47afa59d32288a346e4461ab0ae70b28 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a47afa59d32288a346e4461ab0ae70b28">operator==</a> (const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;other) const </td></tr>
<tr class="memdesc:a47afa59d32288a346e4461ab0ae70b28 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">See the <a class="el" href="classOpenSim_1_1AbstractProperty.html#a5a801d683ef4f717be82244c1b59678d" title="Compare this property with another one; this is primarily used for testing. ">equals()</a> method for the meaning of this operator.  <a href="#a47afa59d32288a346e4461ab0ae70b28">More...</a><br /></td></tr>
<tr class="separator:a47afa59d32288a346e4461ab0ae70b28 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47ef97b89f66793a42c7712275938b5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ab47ef97b89f66793a42c7712275938b5">setAllPropertiesUseDefault</a> (bool shouldUseDefault)</td></tr>
<tr class="memdesc:ab47ef97b89f66793a42c7712275938b5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the "use default" flag for this property and the properties of any objects it contains to the given value.  <a href="#ab47ef97b89f66793a42c7712275938b5">More...</a><br /></td></tr>
<tr class="separator:ab47ef97b89f66793a42c7712275938b5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f988432f0ac82f5e4c787879c16b3e inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ae2f988432f0ac82f5e4c787879c16b3e">readFromXMLParentElement</a> (SimTK::Xml::Element &amp;parent, int versionNumber)</td></tr>
<tr class="memdesc:ae2f988432f0ac82f5e4c787879c16b3e inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an XML parent element expected to contain a value for this property as an immediate child element, find that property element and set the property value from it.  <a href="#ae2f988432f0ac82f5e4c787879c16b3e">More...</a><br /></td></tr>
<tr class="separator:ae2f988432f0ac82f5e4c787879c16b3e inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad446ca804c2733c2d1a63b90e24d9e42 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ad446ca804c2733c2d1a63b90e24d9e42">writeToXMLParentElement</a> (SimTK::Xml::Element &amp;parent) const </td></tr>
<tr class="memdesc:ad446ca804c2733c2d1a63b90e24d9e42 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an XML parent element, append a single child element representing the serialized form of this property.  <a href="#ad446ca804c2733c2d1a63b90e24d9e42">More...</a><br /></td></tr>
<tr class="separator:ad446ca804c2733c2d1a63b90e24d9e42 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29bdc3ab4adbbfe954aed4a0780bee7 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#af29bdc3ab4adbbfe954aed4a0780bee7">setName</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:af29bdc3ab4adbbfe954aed4a0780bee7 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the property name.  <a href="#af29bdc3ab4adbbfe954aed4a0780bee7">More...</a><br /></td></tr>
<tr class="separator:af29bdc3ab4adbbfe954aed4a0780bee7 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1cfb86a10115441ef84be3148c0c7d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#aac1cfb86a10115441ef84be3148c0c7d">setComment</a> (const std::string &amp;aComment)</td></tr>
<tr class="memdesc:aac1cfb86a10115441ef84be3148c0c7d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a user-friendly comment to be associated with property.  <a href="#aac1cfb86a10115441ef84be3148c0c7d">More...</a><br /></td></tr>
<tr class="separator:aac1cfb86a10115441ef84be3148c0c7d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ec6fb0a5d6beaef87cf228b34d48cf inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">setValueIsDefault</a> (bool isDefault)</td></tr>
<tr class="memdesc:a10ec6fb0a5d6beaef87cf228b34d48cf inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set flag indicating whether the value of this property was simply taken from a default object and thus should not be written out when serializing.  <a href="#a10ec6fb0a5d6beaef87cf228b34d48cf">More...</a><br /></td></tr>
<tr class="separator:a10ec6fb0a5d6beaef87cf228b34d48cf inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd68b4e2e7ca1de8236f16ce71cda29 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a5bd68b4e2e7ca1de8236f16ce71cda29">getName</a> () const </td></tr>
<tr class="memdesc:a5bd68b4e2e7ca1de8236f16ce71cda29 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the property name.  <a href="#a5bd68b4e2e7ca1de8236f16ce71cda29">More...</a><br /></td></tr>
<tr class="separator:a5bd68b4e2e7ca1de8236f16ce71cda29 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd0ffc207e76a1a19b70c1e28e7291c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#afcd0ffc207e76a1a19b70c1e28e7291c">getComment</a> () const </td></tr>
<tr class="memdesc:afcd0ffc207e76a1a19b70c1e28e7291c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the comment associated with this property.  <a href="#afcd0ffc207e76a1a19b70c1e28e7291c">More...</a><br /></td></tr>
<tr class="separator:afcd0ffc207e76a1a19b70c1e28e7291c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9332e809f48f55f892eb99064c5b53 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#adb9332e809f48f55f892eb99064c5b53">getValueIsDefault</a> () const </td></tr>
<tr class="memdesc:adb9332e809f48f55f892eb99064c5b53 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the flag indicating whether the current value is just the default value for this property (in which case it doesn't need to be written out).  <a href="#adb9332e809f48f55f892eb99064c5b53">More...</a><br /></td></tr>
<tr class="separator:adb9332e809f48f55f892eb99064c5b53 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d92ed0f4c96fe7810276c5393dfd65 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a08d92ed0f4c96fe7810276c5393dfd65">getMinListSize</a> () const </td></tr>
<tr class="memdesc:a08d92ed0f4c96fe7810276c5393dfd65 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum number of values allowed in this property's value list.  <a href="#a08d92ed0f4c96fe7810276c5393dfd65">More...</a><br /></td></tr>
<tr class="separator:a08d92ed0f4c96fe7810276c5393dfd65 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7ad40bcb2da56c7c7ac6df61127a66 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a6d7ad40bcb2da56c7c7ac6df61127a66">getMaxListSize</a> () const </td></tr>
<tr class="memdesc:a6d7ad40bcb2da56c7c7ac6df61127a66 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum number of values allowed in this property's value list.  <a href="#a6d7ad40bcb2da56c7c7ac6df61127a66">More...</a><br /></td></tr>
<tr class="separator:a6d7ad40bcb2da56c7c7ac6df61127a66 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ee42a879679c03a8a69f99998f2386 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a97ee42a879679c03a8a69f99998f2386">isOptionalProperty</a> () const </td></tr>
<tr class="memdesc:a97ee42a879679c03a8a69f99998f2386 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an "optional" property if its value list can contain at most one value.  <a href="#a97ee42a879679c03a8a69f99998f2386">More...</a><br /></td></tr>
<tr class="separator:a97ee42a879679c03a8a69f99998f2386 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2da76dbb28b3bd2d56dcbdbaf4aa5e inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ada2da76dbb28b3bd2d56dcbdbaf4aa5e">isListProperty</a> () const </td></tr>
<tr class="memdesc:ada2da76dbb28b3bd2d56dcbdbaf4aa5e inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a "list" property if its value list can contain more than one value.  <a href="#ada2da76dbb28b3bd2d56dcbdbaf4aa5e">More...</a><br /></td></tr>
<tr class="separator:ada2da76dbb28b3bd2d56dcbdbaf4aa5e inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9795b6c898304529ca3bc34145b23ea5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a9795b6c898304529ca3bc34145b23ea5">isOneValueProperty</a> () const </td></tr>
<tr class="memdesc:a9795b6c898304529ca3bc34145b23ea5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a "one-value" property if its value list must always contain exactly one value.  <a href="#a9795b6c898304529ca3bc34145b23ea5">More...</a><br /></td></tr>
<tr class="separator:a9795b6c898304529ca3bc34145b23ea5 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b6812da7751667518cd2a282da545c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ad3b6812da7751667518cd2a282da545c">isOneObjectProperty</a> () const </td></tr>
<tr class="memdesc:ad3b6812da7751667518cd2a282da545c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a "one-object" property if it is a "one-value" property and it contains an Object-derived value.  <a href="#ad3b6812da7751667518cd2a282da545c">More...</a><br /></td></tr>
<tr class="separator:ad3b6812da7751667518cd2a282da545c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56581f4582e334d3c1caa6bb69aee6d3 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a56581f4582e334d3c1caa6bb69aee6d3">size</a> () const </td></tr>
<tr class="memdesc:a56581f4582e334d3c1caa6bb69aee6d3 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of values currently in this property's value list.  <a href="#a56581f4582e334d3c1caa6bb69aee6d3">More...</a><br /></td></tr>
<tr class="separator:a56581f4582e334d3c1caa6bb69aee6d3 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216316d68bb344424cead7db1ac71264 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a216316d68bb344424cead7db1ac71264">empty</a> () const </td></tr>
<tr class="memdesc:a216316d68bb344424cead7db1ac71264 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this property's value list is currently empty.  <a href="#a216316d68bb344424cead7db1ac71264">More...</a><br /></td></tr>
<tr class="separator:a216316d68bb344424cead7db1ac71264 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec8c00426c6841139be00515e749713 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a5ec8c00426c6841139be00515e749713">clear</a> ()</td></tr>
<tr class="memdesc:a5ec8c00426c6841139be00515e749713 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty the value list for this property; fails if zero is not an allowable size for this property.  <a href="#a5ec8c00426c6841139be00515e749713">More...</a><br /></td></tr>
<tr class="separator:a5ec8c00426c6841139be00515e749713 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4979ecae361803e961f2f57828b0b31c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a4979ecae361803e961f2f57828b0b31c">getValueAsObject</a> (int index=-1) const  =0</td></tr>
<tr class="memdesc:a4979ecae361803e961f2f57828b0b31c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an object property, the values can be obtained as references to the abstract base class <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> from which all the objects derive.  <a href="#a4979ecae361803e961f2f57828b0b31c">More...</a><br /></td></tr>
<tr class="separator:a4979ecae361803e961f2f57828b0b31c inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66ced70e8820a21c6f0f4c90f155aff inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ac66ced70e8820a21c6f0f4c90f155aff">updValueAsObject</a> (int index=-1)=0</td></tr>
<tr class="memdesc:ac66ced70e8820a21c6f0f4c90f155aff inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get writable access to an existing object value.  <a href="#ac66ced70e8820a21c6f0f4c90f155aff">More...</a><br /></td></tr>
<tr class="separator:ac66ced70e8820a21c6f0f4c90f155aff inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a11f2382a5216af4dbe49209e7ccef inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#ab9a11f2382a5216af4dbe49209e7ccef">setValueAsObject</a> (const <a class="el" href="classOpenSim_1_1Object.html">Object</a> &amp;obj, int index=-1)=0</td></tr>
<tr class="memdesc:ab9a11f2382a5216af4dbe49209e7ccef inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the indicated value element to a new copy of the supplied object.  <a href="#ab9a11f2382a5216af4dbe49209e7ccef">More...</a><br /></td></tr>
<tr class="separator:ab9a11f2382a5216af4dbe49209e7ccef inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e44476b24c4b6830df297b8d78c7f5d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4e44476b24c4b6830df297b8d78c7f5d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a4e44476b24c4b6830df297b8d78c7f5d">getValue</a> (int index=-1) const </td></tr>
<tr class="memdesc:a4e44476b24c4b6830df297b8d78c7f5d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return one of the values in this property as type T; this works only if the underlying concrete property stores type T and if the indexed element is present, otherwise throws an exception.  <a href="#a4e44476b24c4b6830df297b8d78c7f5d">More...</a><br /></td></tr>
<tr class="separator:a4e44476b24c4b6830df297b8d78c7f5d inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08cd08421dc135dface6cb9fb3d1e1c1 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a08cd08421dc135dface6cb9fb3d1e1c1 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a08cd08421dc135dface6cb9fb3d1e1c1">updValue</a> (int index=-1)</td></tr>
<tr class="memdesc:a08cd08421dc135dface6cb9fb3d1e1c1 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a writable reference to one of the values in this property as type T; this works only if the underlying concrete property is actually of type T and the indexed element is present.  <a href="#a08cd08421dc135dface6cb9fb3d1e1c1">More...</a><br /></td></tr>
<tr class="separator:a08cd08421dc135dface6cb9fb3d1e1c1 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05726a6ab0bee46b8f2b07a8931fd90a inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a05726a6ab0bee46b8f2b07a8931fd90a inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a05726a6ab0bee46b8f2b07a8931fd90a">appendValue</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a05726a6ab0bee46b8f2b07a8931fd90a inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a new value of type T to the end of the list of values currently contained in this property.  <a href="#a05726a6ab0bee46b8f2b07a8931fd90a">More...</a><br /></td></tr>
<tr class="separator:a05726a6ab0bee46b8f2b07a8931fd90a inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432c98206f8a695119818f45a0c75204 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1AbstractProperty.html#a432c98206f8a695119818f45a0c75204">assign</a> (const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;that)=0</td></tr>
<tr class="memdesc:a432c98206f8a695119818f45a0c75204 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign (copy) property <em>that</em> to this object.  <a href="#a432c98206f8a695119818f45a0c75204">More...</a><br /></td></tr>
<tr class="separator:a432c98206f8a695119818f45a0c75204 inherit pub_methods_classOpenSim_1_1AbstractProperty"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7a234feb91cb9e416ceaaff20586b17b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#a7a234feb91cb9e416ceaaff20586b17b">isA</a> (const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;prop)</td></tr>
<tr class="memdesc:a7a234feb91cb9e416ceaaff20586b17b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the given <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> references a concrete property of this type (Property&lt;T&gt;).  <a href="#a7a234feb91cb9e416ceaaff20586b17b">More...</a><br /></td></tr>
<tr class="separator:a7a234feb91cb9e416ceaaff20586b17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9729da476501b3fb9cfcdcf16f531e7"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classOpenSim_1_1Property.html">Property</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#ac9729da476501b3fb9cfcdcf16f531e7">getAs</a> (const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;prop)</td></tr>
<tr class="memdesc:ac9729da476501b3fb9cfcdcf16f531e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downcast the given <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> to a concrete property of this type (Property&lt;T&gt;).  <a href="#ac9729da476501b3fb9cfcdcf16f531e7">More...</a><br /></td></tr>
<tr class="separator:ac9729da476501b3fb9cfcdcf16f531e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac416f4ac135fcadc1a35b47b3cd36f0b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classOpenSim_1_1Property.html">Property</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenSim_1_1Property.html#ac416f4ac135fcadc1a35b47b3cd36f0b">updAs</a> (<a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a> &amp;prop)</td></tr>
<tr class="memdesc:ac416f4ac135fcadc1a35b47b3cd36f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Downcast the given <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> to a writable concrete property of this type (Property&lt;T&gt;).  <a href="#ac416f4ac135fcadc1a35b47b3cd36f0b">More...</a><br /></td></tr>
<tr class="separator:ac416f4ac135fcadc1a35b47b3cd36f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description </h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class OpenSim::Property&lt; T &gt;</h3>

<p>A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T. </p>
<p>The number of values allowed in the list is an attribute of the property; often it is just a single value. Properties are owned by classes that derive from OpenSim's serializable <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> base class. The documentation here is most useful for developers who are interested in creating a new <a class="el" href="classOpenSim_1_1Component.html" title="The abstract Component class defines the interface used to add computational elements to the underlyi...">Component</a>, <a class="el" href="classOpenSim_1_1ModelComponent.html" title="This defines the abstract ModelComponent class, which is used to specify components of a musculoskele...">ModelComponent</a>, or other serializable class derived from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>.</p>
<p>A property's contained type T must be a serializable type. Serializable types come in two flavors:</p><ul>
<li>simple types (like int or string) for which serialization instructions have been provided, and</li>
<li>object types, in which case type T derives from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> and knows how to serialize itself.</li>
</ul>
<p>When T is a simple type we'll write T=S and refer to a Property&lt;S&gt; as a "simple property". When T is an object type, we'll write T=O and refer to a Property&lt;O&gt; as an "object property".</p>
<p>In case type O is a still-abstract Object-derived type like <a class="el" href="classOpenSim_1_1Function.html" title="An abstract class for representing a function. ">Function</a> or <a class="el" href="classOpenSim_1_1Controller.html" title="Controller is an abstract ModelComponent that defines the interface for an OpenSim Controller...">Controller</a>, a Property&lt;O&gt; can hold a mix of any concrete objects derived from O (e.g., any <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> that can be dynamic_cast to a <a class="el" href="classOpenSim_1_1Function.html" title="An abstract class for representing a function. ">Function</a> can be held by a Property&lt;<a class="el" href="classOpenSim_1_1Function.html" title="An abstract class for representing a function. ">Function</a>&gt;).</p>
<p>The objects in an object property will themselves have properties so a Property&lt;O&gt; can be viewed as a node in the tree of objects that constitute an OpenSim <a class="el" href="classOpenSim_1_1Model.html" title="A concrete class that specifies the interface to a musculoskeletal model. ">Model</a>. Simple properties Property&lt;S&gt; can be viewed as the terminal nodes of that tree. Properties are thus an integral part of the structure of an OpenSim <a class="el" href="classOpenSim_1_1Model.html" title="A concrete class that specifies the interface to a musculoskeletal model. ">Model</a>; anything contained in a property is owned by that property; deleting the property deletes its contained objects. If you want to <em>reference</em> another <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> from within a property, use a string property to reference it by name; the result is a simple property. It is not permitted for type T to be a pointer or reference.</p>
<h3>XML file representation of properties</h3>
<p>The general representation for a Property&lt;T&gt; with name "prop_name" is </p><div class="fragment"><div class="line">&lt;prop_name&gt; T T ... T &lt;/prop_name&gt;</div></div><!-- fragment --><p> where "T" is the XML representation for objects of type T. Note that if T is an object type O, its representation follows the pattern </p><div class="fragment"><div class="line">&lt;OTypeName&gt; OContents &lt;/OTypeName&gt;</div></div><!-- fragment --><p> where <code>OTypeName</code> stands for the name of the concrete, Object-derived class being serialized, and <code>OContents</code> is the representation generated by that class when asked to serialize itself.</p>
<p>A Property&lt;O&gt; that is restricted to holding <em>exactly one</em> object of type O is called a "one-object property". It could be represented in XML as </p><div class="fragment"><div class="line">&lt;prop_name&gt; &lt;OTypeName&gt; OContents &lt;/OTypeName&gt; &lt;/prop_name&gt;</div></div><!-- fragment --><p> but we allow a more compact representation for one-object properties: </p><div class="fragment"><div class="line">&lt;OTypeName name=<span class="stringliteral">&quot;prop_name&quot;</span>&gt; OContents &lt;/OTypeName&gt;</div></div><!-- fragment --><p> In the one-object case it is also permissible for the property to be unnamed, in which case it may be referenced as though its name were the same as the object type name, and there is no separate "name" attribute. The XML representation for an unnamed property is just: </p><div class="fragment"><div class="line">&lt;OTypeName&gt; OContents &lt;/OTypeName&gt;</div></div><!-- fragment --><p> On input, if a name attribute is seen for an unnamed property it is ignored; only the object type name tag matters in the unnamed case. Note that only one-object properties can be unnamed, and no single OpenSim object can have more than one unnamed property of the same type.</p>
<h3>Property attributes</h3>
<p>In addition to the name and list of values, every property has the following attributes:</p><ul>
<li>A comment string, provided at the time the property is created.</li>
<li>The minimum and maximum number of values allowed.</li>
<li>A "used default value" flag.</li>
</ul>
<p>The "used default value" flag specifies that the value stored with this property was taken from a default object and not subsequently changed. A property with this flag set is not written out when a model is serialized.</p>
<h3>How to declare properties in your class declaration</h3>
<p>Properties are maintained in a <a class="el" href="classOpenSim_1_1PropertyTable.html" title="A property table is the container that an OpenSim Object uses to hold its properties (each derived fr...">PropertyTable</a> by OpenSim's <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> base class that is used for all serializable objects. Do not create Property objects directly; instead, use the provided macros to declare them in the class declarations for objects derived from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>. These macros should appear in the header file near the top of your class declaration. Comments that should appear in the generated Doxygen documentation as well as in XML files should be in the comment string; if you have a comment that should appear in Doxygen documentation but not in XML, then you can place it in a Doxygen comment just above the line where you declare your property.</p>
<p><b>Naming conventions:</b> OpenSim property names should use lower case letters with <code>words_separated_by_underscores</code>. In contrast, OpenSim object types begin with a capital letter and use camel case, that is, <code>MixedUpperAndLowerLikeThis</code>. This prevents any possible collisions between property names and object types, allowing both to be used as XML tag identifiers with no conflicts.</p>
<p>These are the most common forms of property declaration. Click on the macro names below for more information. </p><div class="fragment"><div class="line"><span class="comment">// Exactly one value required; this is the basic property type.</span></div><div class="line"><a class="code" href="classOpenSim_1_1Property.html#aa3ae917a7d77f92f49f7a0fb4cbed75b">OpenSim_DECLARE_PROPERTY</a>(name, T, <span class="stringliteral">&quot;property description&quot;</span>);</div><div class="line"><span class="comment">// Zero or one value only.</span></div><div class="line"><a class="code" href="classOpenSim_1_1Property.html#a3c62d71bf8f0c47b7a22d7400066cef0">OpenSim_DECLARE_OPTIONAL_PROPERTY</a>(name, T, <span class="stringliteral">&quot;property description&quot;</span>);</div><div class="line"><span class="comment">// Zero or more values.</span></div><div class="line"><a class="code" href="classOpenSim_1_1Property.html#aaf2e667234fb198a5dacb6fd7c1b62e8">OpenSim_DECLARE_LIST_PROPERTY</a>(name, T, <span class="stringliteral">&quot;property description&quot;</span>);</div></div><!-- fragment --><p> In the above, T may be a simple type S or object type O. In the case of a single-value property where type T is a type derived from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> (i.e., T=O), you can declare the property to be unnamed and instead use the class name of the object type O to identify the property: </p><div class="fragment"><div class="line"><span class="comment">// Exactly one value of object type O required.</span></div><div class="line"><a class="code" href="classOpenSim_1_1Property.html#adeade60afd2e1a48bbfd68911362f0b9">OpenSim_DECLARE_UNNAMED_PROPERTY</a>(O, <span class="stringliteral">&quot;property description&quot;</span>);</div></div><!-- fragment --><p> Only one unnamed property of a particular object type O may be declared in any given <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a>.</p>
<p>Finally, for list properties you can declare restrictions on the allowable list length: </p><div class="fragment"><div class="line"><span class="comment">// List must contain exactly listSize (&gt; 0) elements.</span></div><div class="line"><a class="code" href="classOpenSim_1_1Property.html#a082bb85d3c7e5a177a03aea98b123cd6">OpenSim_DECLARE_LIST_PROPERTY_SIZE</a>(name, T, listSize, </div><div class="line">                                   <span class="stringliteral">&quot;property description&quot;</span>);</div><div class="line"><span class="comment">// List must contain at least minSize (&gt; 0) elements.</span></div><div class="line"><a class="code" href="classOpenSim_1_1Property.html#a04e9ee4d251db381f48929f172bdf214">OpenSim_DECLARE_LIST_PROPERTY_ATLEAST</a>(name, T, minSize, </div><div class="line">                                      <span class="stringliteral">&quot;property description&quot;</span>);</div><div class="line"><span class="comment">// List must contain at most maxSize (&gt; 0) elements.</span></div><div class="line"><a class="code" href="classOpenSim_1_1Property.html#a8eb0eb8d9890fe369fa35b34e8c019e7">OpenSim_DECLARE_LIST_PROPERTY_ATMOST</a>(name, T, maxSize, </div><div class="line">                                     <span class="stringliteral">&quot;property description&quot;</span>);</div><div class="line"><span class="comment">// List must contain between minSize (&gt; 0) and maxSize (&gt;minSize) elements.</span></div><div class="line"><a class="code" href="classOpenSim_1_1Property.html#a7c0cc6d50e83042c525d423cc1e1a56b">OpenSim_DECLARE_LIST_PROPERTY_RANGE</a>(name, T, minSize, maxSize, </div><div class="line">                                    <span class="stringliteral">&quot;property description&quot;</span>);</div></div><!-- fragment --><p> Here is an example of an object declaring two properties: </p><div class="fragment"><div class="line"><span class="keyword">class </span>ActuatorWorkMeter : <span class="keyword">public</span> ModelComponent {</div><div class="line">OpenSim_DECLARE_CONCRETE_OBJECT(ActuatorWorkMeter, ModelComponent);</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="comment">//=======================================================================</span></div><div class="line"><span class="comment">// PROPERTIES</span></div><div class="line"><span class="comment">//=======================================================================</span></div><div class="line">    <a class="code" href="classOpenSim_1_1Property.html#aa3ae917a7d77f92f49f7a0fb4cbed75b">OpenSim_DECLARE_PROPERTY</a>(actuator_name, std::string,</div><div class="line">        <span class="stringliteral">&quot;The name of the actuator whose work use will be calculated.&quot;</span>);</div><div class="line">    <a class="code" href="classOpenSim_1_1Property.html#aa3ae917a7d77f92f49f7a0fb4cbed75b">OpenSim_DECLARE_PROPERTY</a>(initial_actuator_work, <span class="keywordtype">double</span>,</div><div class="line">        <span class="stringliteral">&quot;Initial value for work; normally zero.&quot;</span>);</div><div class="line"><span class="comment">//=======================================================================</span></div><div class="line"><span class="comment">// PUBLIC METHODS</span></div><div class="line"><span class="comment">//=======================================================================</span></div><div class="line">    ...</div><div class="line">};</div></div><!-- fragment --> <h3>How to construct properties in your constructors</h3>
<p>The constructors for your Object-derived class are required to construct and initialize the properties to whatever default values you want them to have. The above macros will have generated for each property a method for this purpose. If your property is named <em>prop_name</em>, then the method will be called constructProperty_<em>prop_name</em>(). (In the case of unnamed properties, the object type serves as <em>prop_name</em>.) The initial value is provided as an argument, which is optional for those properties that are allowed to contain a zero-length value list. Here are the various types of generated construction methods: </p><div class="fragment"><div class="line"><span class="comment">// Construct and initialize a single-valued property containing type T.</span></div><div class="line"><span class="keywordtype">void</span> constructProperty_prop_name(<span class="keyword">const</span> T&amp; value);</div><div class="line"><span class="comment">// Construct a property with a zero-length value list. </span></div><div class="line"><span class="keywordtype">void</span> constructProperty_prop_name();</div><div class="line"><span class="comment">// Construct a list property, initializing from a container.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>Container&gt;</div><div class="line"><span class="keywordtype">void</span> constructProperty_prop_name(<span class="keyword">const</span> Container&lt;T&gt;&amp; valueList);</div></div><!-- fragment --><p> The first form above is generated for basic, optional, and unnamed properties. The second, uninitialized form is generated for optional, unrestricted list, and list "atmost" properties, since those can accept a zero-element value list. The last form is generated for all list properties, regardless of size restriction; a runtime check verifies that size restrictions are met. That form accepts any container type that supports a size() method and random access element selection with operator[], such as std::vector&lt;T&gt;, OpenSim::Array&lt;T&gt;, or SimTK::Array_&lt;T&gt;.</p>
<p>The above methods are conventionally collected into a private method of each object class called <code>constructProperties()</code>. This method is then invoked from every constructor, <em>except</em> the copy constructor (which you normally should let the compiler generate, but see below).</p>
<h4>Copy constructor and copy assignment operator</h4>
<p>Your best bet is to use the compiler-generated default copy constructor and default copy assignment operator that you get whenever you leave these methods undefined. If you do that, all your properties and their associated local data will be copied automatically. It is worth some effort to design your objects so that their data members can copy and assign themselves correctly; you might find SimTK::ReferencePtr&lt;T&gt; and SimTK::ClonePtr&lt;T&gt; useful for getting pointer members to behave themselves properly.</p>
<p>However, if you do have to write your own copy constructor and copy assignment operator (and if you write one you must write the other also), the property table will still have been copied properly by your superclass, it is only the local property indices that you have to deal with. For that, each property has defined a method like: </p><div class="fragment"><div class="line"><span class="comment">// Copy the local data member associated with property prop_name.</span></div><div class="line"><span class="keywordtype">void</span> copyProperty_prop_name(<span class="keyword">const</span> Self&amp; source);</div></div><!-- fragment --><p> In the above, <code>Self</code> is the type of the object being defined and <code>source</code> is the argument that was passed to the containing copy constructor or copy assignment operator.</p>
<h3>Runtime access to property values</h3>
<p>The property declaration macros also generate per-property methods for getting access to property values or the Property objects themselves. These inline methods are very fast and can be used whenever you need access to a property value. The following are generated for single-valued property types, including the basic, optional, and unnamed properties: </p><div class="fragment"><div class="line"><span class="comment">// Get a const reference to the value of a single-valued property </span></div><div class="line"><span class="comment">// named &quot;prop_name&quot; (basic, optional, unnamed properties only).</span></div><div class="line"><span class="keyword">const</span> T&amp; get_prop_name() <span class="keyword">const</span>;</div><div class="line"><span class="comment">// Same, but returns a writable reference.</span></div><div class="line">T&amp; upd_prop_name();</div><div class="line"><span class="comment">// Set the value of a single-valued property.</span></div><div class="line"><span class="keywordtype">void</span> set_prop_name(<span class="keyword">const</span> T&amp; value);</div></div><!-- fragment --><p>Additional methods are generated for list properties: </p><div class="fragment"><div class="line"><span class="comment">// Get a const reference to the i&#39;th element in a list property&#39;s value </span></div><div class="line"><span class="comment">// list.</span></div><div class="line"><span class="keyword">const</span> T&amp; get_prop_name(<span class="keywordtype">int</span> i) <span class="keyword">const</span>;</div><div class="line"><span class="comment">// Same, but returns a writable reference.</span></div><div class="line">T&amp; upd_prop_name(<span class="keywordtype">int</span> i);</div><div class="line"><span class="comment">// Set the i&#39;th element of a list property to the given value. Only </span></div><div class="line"><span class="comment">// allowed if the list currently has at least i elements, so no gaps can</span></div><div class="line"><span class="comment">// be created with this method.</span></div><div class="line"><span class="keywordtype">void</span> set_prop_name(<span class="keywordtype">int</span> i, <span class="keyword">const</span> T&amp; value);</div><div class="line"><span class="comment">// Use this to append one element to a list property&#39;s value list; the</span></div><div class="line"><span class="comment">// assigned index is returned.</span></div><div class="line"><span class="keywordtype">int</span> append_prop_name(<span class="keyword">const</span> T&amp; value);</div><div class="line"><span class="comment">// Use this to set all the values of a list-valued property.</span></div><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="keyword">class </span>Container&gt;</div><div class="line"><span class="keywordtype">void</span> set_prop_name(<span class="keyword">const</span> Container&lt;T&gt;&amp; valueList);</div></div><!-- fragment --><p> The last form accepts any container that has a size() method and allows element access using operator[]. Runtime checks verify that the list length is within the allowable range for the property. Note that every property is considered to have a value list (even when restricted to one element) so the indexed forms above can also be used with single-valued properties as long as the index is zero.</p>
<p>To get access to the Property object rather than one of its values, the following methods are provided: </p><div class="fragment"><div class="line"><span class="comment">// Get a const reference to the Property&lt;T&gt; object for &quot;prop_name&quot;.</span></div><div class="line"><span class="keyword">const</span> Property&lt;T&gt;&amp; getProperty_prop_name() <span class="keyword">const</span>;</div><div class="line"><span class="comment">// Same, but returns a writable reference.</span></div><div class="line">Property&lt;T&gt;&amp; updProperty_prop_name();</div></div><!-- fragment --><p>The Property&lt;T&gt; class acts as a container of values, and has the usual size(), empty(), and operator[] methods available so you can use getProperty...() above to get access to those methods. For example, to write out all the values of any property: </p><div class="fragment"><div class="line"><span class="comment">// Assumes type T can be written to a stream with operator&lt;&lt;.</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; getProperty_prop_name().size(); ++i)</div><div class="line">    std::cout &lt;&lt; get_prop_name(i) &lt;&lt; std::endl;</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">OpenSim::Object</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">OpenSim::AbstractProperty</a> </dd></dl>
<dl class="section author"><dt>Author</dt><dd>Michael Sherman </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa062d40d7e621c8891e2eefcd9cd6215"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::<a class="el" href="classOpenSim_1_1Property.html">Property</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classOpenSim_1_1Property.html#ac416f4ac135fcadc1a35b47b3cd36f0b">OpenSim::Property&lt; T &gt;::updAs()</a>.</p>

</div>
</div>
<a class="anchor" id="a5d9596fe70f1c128d31a4034a27e175c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::~<a class="el" href="classOpenSim_1_1Property.html">Property</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Referenced by <a class="el" href="classOpenSim_1_1Property.html#ac416f4ac135fcadc1a35b47b3cd36f0b">OpenSim::Property&lt; T &gt;::updAs()</a>.</p>

</div>
</div>
<a class="anchor" id="a940f9f9b08ec3835b625a63a2ede3a70"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::<a class="el" href="classOpenSim_1_1Property.html">Property</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Property.html">Property</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ada8afb4114ae6dc828039f9473bf3f6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::<a class="el" href="classOpenSim_1_1Property.html">Property</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Property.html">Property</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7f955ce364fd5c6a031263894a77c6a2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::adoptAndAppendValue </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new value to the end of this property's value list, taking over ownership of the supplied heap-allocated object. </p>
<p>An exception is thrown if the property can't hold any more values. The index assigned to this value is returned. </p>

<p>References <a class="el" href="classOpenSim_1_1AbstractProperty.html#a6d7ad40bcb2da56c7c7ac6df61127a66">OpenSim::AbstractProperty::getMaxListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a5bd68b4e2e7ca1de8236f16ce71cda29">OpenSim::AbstractProperty::getName()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a7b3a44098854548c769a926cfc97b3f7">OpenSim::AbstractProperty::getNumValues()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">OpenSim::AbstractProperty::setValueIsDefault()</a>.</p>

</div>
</div>
<a class="anchor" id="a8cebe3dfc74cb4f1d5158a4feb449e05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::appendValue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a copy of the supplied <em>value</em> to the end of this property's value list. </p>
<p>An exception is thrown if the property can't hold any more values. The index assigned to this value is returned. </p>

<p>References <a class="el" href="classOpenSim_1_1AbstractProperty.html#a6d7ad40bcb2da56c7c7ac6df61127a66">OpenSim::AbstractProperty::getMaxListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a5bd68b4e2e7ca1de8236f16ce71cda29">OpenSim::AbstractProperty::getName()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a7b3a44098854548c769a926cfc97b3f7">OpenSim::AbstractProperty::getNumValues()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">OpenSim::AbstractProperty::setValueIsDefault()</a>.</p>

<p>Referenced by <a class="el" href="classOpenSim_1_1Object.html#a2e09382ab2bb833eba12c081f35b5a2d">OpenSim::Object::addListProperty()</a>, <a class="el" href="classOpenSim_1_1Object.html#affef953ecb6526d5de51f8d045229d79">OpenSim::Object::addOptionalProperty()</a>, <a class="el" href="classOpenSim_1_1Object.html#af24322b3b4552de29ed0589a03ba7ad5">OpenSim::Object::addProperty()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a05726a6ab0bee46b8f2b07a8931fd90a">OpenSim::AbstractProperty::appendValue()</a>, and <a class="el" href="classOpenSim_1_1Property.html#a3a8b68f9fa4cf67c5b9d681b4499d63e">OpenSim::Property&lt; T &gt;::setValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a7f8d2992c9f493380aa3400a6f6ec9a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::appendValue </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a <em>copy</em> of the supplied <em>value</em> to the end of this property's value list. </p>
<p>An exception is thrown if the property can't hold any more values. The index assigned to this value is returned. Note that although we accept a pointer here, we do not take over ownership. See <a class="el" href="classOpenSim_1_1Property.html#a7f955ce364fd5c6a031263894a77c6a2" title="Add a new value to the end of this property&#39;s value list, taking over ownership of the supplied heap-...">adoptAndAppendValue()</a> if you want the property to take ownership. </p>

<p>References <a class="el" href="classOpenSim_1_1AbstractProperty.html#a6d7ad40bcb2da56c7c7ac6df61127a66">OpenSim::AbstractProperty::getMaxListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a5bd68b4e2e7ca1de8236f16ce71cda29">OpenSim::AbstractProperty::getName()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a7b3a44098854548c769a926cfc97b3f7">OpenSim::AbstractProperty::getNumValues()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">OpenSim::AbstractProperty::setValueIsDefault()</a>.</p>

</div>
</div>
<a class="anchor" id="a04c7dbc509b6247209320f4cffa3e335"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">Property</a>* <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a new, deep copy (clone) of this concrete property and return a pointer to the heap space. </p>
<p>Caller must delete the returned object when done with it. </p>

<p>Implements <a class="el" href="classOpenSim_1_1AbstractProperty.html#af5ec984319710024bbd4b30cae2fa9c0">OpenSim::AbstractProperty</a>.</p>

<p>Referenced by <a class="el" href="classOpenSim_1_1Property.html#aa7bc4edc7b1102885371bbeece620f43">OpenSim::Property&lt; T &gt;::getTypeName()</a>.</p>

</div>
</div>
<a class="anchor" id="a9169673da96ab5c0da51048ef331f134"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::findIndex </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search the value list for an element that has the given <em>value</em> and return its index if found, otherwise -1. </p>
<p>This requires only that the template type T supports <a class="el" href="classOpenSim_1_1AbstractProperty.html#a47afa59d32288a346e4461ab0ae70b28" title="See the equals() method for the meaning of this operator. ">operator==()</a>. This is a linear search so will take time proportional to the length of the value list. </p>

<p>References <a class="el" href="classOpenSim_1_1Property.html#aca5557f6f0e504ab3e8360574019a500">OpenSim::Property&lt; T &gt;::findIndexForName()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a7b3a44098854548c769a926cfc97b3f7">OpenSim::AbstractProperty::getNumValues()</a>, and <a class="el" href="classOpenSim_1_1Property.html#a66e1ead8242e6c28a48c1a99b849ecfb">OpenSim::Property&lt; T &gt;::getValue()</a>.</p>

</div>
</div>
<a class="anchor" id="aca5557f6f0e504ab3e8360574019a500"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::findIndexForName </td>
          <td>(</td>
          <td class="paramtype">const SimTK::String &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return index of passed in name if the <a class="el" href="classOpenSim_1_1Property.html" title="A Property&lt;T&gt; is a serializable (name, list-of-values) pair, where each value is of type T...">Property</a> contains objects that are derived from <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">OpenSim::Object</a>, and -1 if no such <a class="el" href="classOpenSim_1_1Object.html" title="This is the base class for all OpenSim objects that are serializable (meaning they can be written to ...">Object</a> is found. </p>
<p>Throws an <a class="el" href="classOpenSim_1_1Exception.html" title="A class for basic exception functionality. ">Exception</a> if the List doesn't contain <a class="el" href="namespaceOpenSim.html">OpenSim</a> Objects (e.g. primitive types) since these are not named. When a search is performed, it's a linear search. </p>

<p>Referenced by <a class="el" href="classOpenSim_1_1Property.html#a9169673da96ab5c0da51048ef331f134">OpenSim::Property&lt; T &gt;::findIndex()</a>, and <a class="el" href="classOpenSim_1_1Property.html#aa7bc4edc7b1102885371bbeece620f43">OpenSim::Property&lt; T &gt;::getTypeName()</a>.</p>

</div>
</div>
<a class="anchor" id="ac9729da476501b3fb9cfcdcf16f531e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classOpenSim_1_1Property.html">Property</a>&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::getAs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downcast the given <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> to a concrete property of this type (Property&lt;T&gt;). </p>
<p>An exception is thrown if this is not the right type only in DEBUG mode; see <a class="el" href="classOpenSim_1_1Property.html#a7a234feb91cb9e416ceaaff20586b17b" title="Return true if the given AbstractProperty references a concrete property of this type (Property&lt;T&gt;)...">isA()</a> if you need to check first. </p>

<p>References <a class="el" href="classOpenSim_1_1AbstractProperty.html#a5bd68b4e2e7ca1de8236f16ce71cda29">OpenSim::AbstractProperty::getName()</a>.</p>

<p>Referenced by <a class="el" href="classOpenSim_1_1PropertyTable.html#a0b2259df66774234d9cf395fa9d8bd84">OpenSim::PropertyTable::getProperty()</a>, and <a class="el" href="classOpenSim_1_1Property.html#aa7bc4edc7b1102885371bbeece620f43">OpenSim::Property&lt; T &gt;::getTypeName()</a>.</p>

</div>
</div>
<a class="anchor" id="aa7bc4edc7b1102885371bbeece620f43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::getTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">final</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use <a class="el" href="structOpenSim_1_1Property_1_1TypeHelper.html" title="This is the generic definition of Property::TypeHelper to be used whenever T does not have a speciali...">TypeHelper</a>'s <a class="el" href="classOpenSim_1_1Property.html#aa7bc4edc7b1102885371bbeece620f43" title="Use TypeHelper&#39;s getTypeName() to satisfy this pure virtual. ">getTypeName()</a> to satisfy this pure virtual. </p>

<p>Implements <a class="el" href="classOpenSim_1_1AbstractProperty.html#aed66bbeb2ee2553a4108b6db6272cbb3">OpenSim::AbstractProperty</a>.</p>

<p>References <a class="el" href="classOpenSim_1_1AbstractProperty.html#a432c98206f8a695119818f45a0c75204">OpenSim::AbstractProperty::assign()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#ac821e78df89632d595e2db657a7986ea">OpenSim::AbstractProperty::clearValues()</a>, <a class="el" href="classOpenSim_1_1Property.html#a04c7dbc509b6247209320f4cffa3e335">OpenSim::Property&lt; T &gt;::clone()</a>, <a class="el" href="structOpenSim_1_1Property_1_1TypeHelper.html#abfb9c62fdbdfc45fb42220c73e19a883">OpenSim::Property&lt; T &gt;::TypeHelper::create()</a>, <a class="el" href="classOpenSim_1_1Property.html#aca5557f6f0e504ab3e8360574019a500">OpenSim::Property&lt; T &gt;::findIndexForName()</a>, <a class="el" href="classOpenSim_1_1Property.html#ac9729da476501b3fb9cfcdcf16f531e7">OpenSim::Property&lt; T &gt;::getAs()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a6d7ad40bcb2da56c7c7ac6df61127a66">OpenSim::AbstractProperty::getMaxListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a08d92ed0f4c96fe7810276c5393dfd65">OpenSim::AbstractProperty::getMinListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a5bd68b4e2e7ca1de8236f16ce71cda29">OpenSim::AbstractProperty::getName()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a7b3a44098854548c769a926cfc97b3f7">OpenSim::AbstractProperty::getNumValues()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#aed66bbeb2ee2553a4108b6db6272cbb3">OpenSim::AbstractProperty::getTypeName()</a>, <a class="el" href="structOpenSim_1_1Property_1_1TypeHelper.html#a5e3662331fb48ce450250b15f5dbdfbb">OpenSim::Property&lt; T &gt;::TypeHelper::getTypeName()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a4979ecae361803e961f2f57828b0b31c">OpenSim::AbstractProperty::getValueAsObject()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#adb9332e809f48f55f892eb99064c5b53">OpenSim::AbstractProperty::getValueIsDefault()</a>, <a class="el" href="classOpenSim_1_1Property.html#a7a234feb91cb9e416ceaaff20586b17b">OpenSim::Property&lt; T &gt;::isA()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a66c0bd3e86c5bff529605df7cf362fd3">OpenSim::AbstractProperty::isAcceptableObjectTag()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#afa05a7ebe68369f36b916aa74d038c31">OpenSim::AbstractProperty::isEqualTo()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#af80471cf2036a18f722b01e972a2717f">OpenSim::AbstractProperty::isObjectProperty()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a9795b6c898304529ca3bc34145b23ea5">OpenSim::AbstractProperty::isOneValueProperty()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a1d1e407bf29ddbc9683b4e4c69fe323c">OpenSim::AbstractProperty::isUnnamedProperty()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#affa9140e7f33c76fd39546c8899e2f05">OpenSim::AbstractProperty::readFromXMLElement()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a0685f52599efbdd68462babddd4859e4">OpenSim::AbstractProperty::setAllowableListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#af29bdc3ab4adbbfe954aed4a0780bee7">OpenSim::AbstractProperty::setName()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#ab9a11f2382a5216af4dbe49209e7ccef">OpenSim::AbstractProperty::setValueAsObject()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a56581f4582e334d3c1caa6bb69aee6d3">OpenSim::AbstractProperty::size()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a5c4743e1d3ce8f0dc41e6320e13041ac">OpenSim::AbstractProperty::toString()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a0d31d4e4d2df0f3c2fe71d46845e4f13">OpenSim::AbstractProperty::toStringForDisplay()</a>, <a class="el" href="classOpenSim_1_1Property.html#ac416f4ac135fcadc1a35b47b3cd36f0b">OpenSim::Property&lt; T &gt;::updAs()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#ac66ced70e8820a21c6f0f4c90f155aff">OpenSim::AbstractProperty::updValueAsObject()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a0235ce9c4572d34ab0a8a550bb97f6cf">OpenSim::AbstractProperty::writeToXMLElement()</a>.</p>

</div>
</div>
<a class="anchor" id="a66e1ead8242e6c28a48c1a99b849ecfb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::getValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the selected value from this property's value list. </p>
<p>If the property is at most single valued then the <em>index</em> is optional and we'll behave as though index=0 were supplied. You can use the square bracket operator property[index] instead. </p>

<p>References <a class="el" href="classOpenSim_1_1AbstractProperty.html#a6d7ad40bcb2da56c7c7ac6df61127a66">OpenSim::AbstractProperty::getMaxListSize()</a>.</p>

<p>Referenced by <a class="el" href="classOpenSim_1_1Property.html#a9169673da96ab5c0da51048ef331f134">OpenSim::Property&lt; T &gt;::findIndex()</a>, and <a class="el" href="classOpenSim_1_1Property.html#a7e132b9552b6c2a9cc8f6a33576fcb1a">OpenSim::Property&lt; T &gt;::operator[]()</a>.</p>

</div>
</div>
<a class="anchor" id="a7a234feb91cb9e416ceaaff20586b17b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::isA </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if the given <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> references a concrete property of this type (Property&lt;T&gt;). </p>
<p>Note that for this to return true, the type T must be exactly the type used when the concrete property was allocated; it is not sufficient for T to be a more general base type from which the actual type was derived. </p>

<p>Referenced by <a class="el" href="classOpenSim_1_1Property.html#aa7bc4edc7b1102885371bbeece620f43">OpenSim::Property&lt; T &gt;::getTypeName()</a>.</p>

</div>
</div>
<a class="anchor" id="aa9c23999672ed5ec0d74d140a67e89ea"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">Property</a>&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment to a value of type T sets the value of this single-valued property to a copy of the supplied <em>value</em>; not allowed for a list property. </p>
<p>This does not invoke the assignment operator on the existing value. Instead, the value list is cleared and then replaced by the new value. This is synonymous with setValue(value). </p>

<p>References <a class="el" href="classOpenSim_1_1Property.html#a3a8b68f9fa4cf67c5b9d681b4499d63e">OpenSim::Property&lt; T &gt;::setValue()</a>.</p>

<p>Referenced by <a class="el" href="classOpenSim_1_1Property.html#ac416f4ac135fcadc1a35b47b3cd36f0b">OpenSim::Property&lt; T &gt;::updAs()</a>.</p>

</div>
</div>
<a class="anchor" id="af3f1f6ba165cb5bd24cab98a22a8076c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;template&lt; class &gt; class Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">Property</a>&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Container&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment to a container of values of type T sets the entire value list of this list property to a copy of the values in the container. </p>
<p>The current value list is cleared before the assignment. This is synonymous with setValue(valueList). </p>

<p>References <a class="el" href="classOpenSim_1_1Property.html#a3a8b68f9fa4cf67c5b9d681b4499d63e">OpenSim::Property&lt; T &gt;::setValue()</a>.</p>

</div>
</div>
<a class="anchor" id="ae29e9433e3c00ddae30ae629b04fb0a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">Property</a>&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOpenSim_1_1Property.html">Property</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a05a9dcdfb4969704946a19931f0bf252"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOpenSim_1_1Property.html">Property</a>&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1Property.html">Property</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7e132b9552b6c2a9cc8f6a33576fcb1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to one of the values in the value list. </p>
<p>This will throw an exception if the index does not refer to an already-existing value. This operator is synonymous with getValue(i). </p>

<p>References <a class="el" href="classOpenSim_1_1Property.html#a66e1ead8242e6c28a48c1a99b849ecfb">OpenSim::Property&lt; T &gt;::getValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a567d26efb726367aca90f2534b032352"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a writable reference to one of the values in the value list. </p>
<p>This will throw an exception if the index does not refer to an already-existing value. This operator is synonymous with updValue(i). </p>

<p>References <a class="el" href="classOpenSim_1_1Property.html#ae597340fa1da9385439bbebf91a6a92a">OpenSim::Property&lt; T &gt;::updValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a3a8b68f9fa4cf67c5b9d681b4499d63e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::setValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replace the i'th value list element with a copy of the given <em>value</em>. </p>
<p>The index i must be between 0 and the current list length, meaning it is OK to refer one element past the last element. In that case the new <em>value</em> is appended to the list using <a class="el" href="classOpenSim_1_1Property.html#a8cebe3dfc74cb4f1d5158a4feb449e05" title="Append a copy of the supplied value to the end of this property&#39;s value list. ">appendValue()</a>, which will throw an exception if the list is already at its maximum allowable size. In the case where index i refers to an existing element, a simple property will assign a new value to the existing element but an object property will delete the old object and replace it with a <a class="el" href="classOpenSim_1_1Property.html#a04c7dbc509b6247209320f4cffa3e335" title="Make a new, deep copy (clone) of this concrete property and return a pointer to the heap space...">clone()</a> of the new one &ndash; it will <em>not</em> invoke the old object's assignment operator. That means that the concrete object type may be changed by this operation, provided it is still a type derived from object type T. If you want to invoke the existing value's assignment operator, use updValue(i) rather than setValue(i). </p>

<p>References <a class="el" href="classOpenSim_1_1Property.html#a8cebe3dfc74cb4f1d5158a4feb449e05">OpenSim::Property&lt; T &gt;::appendValue()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a5bd68b4e2e7ca1de8236f16ce71cda29">OpenSim::AbstractProperty::getName()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a7b3a44098854548c769a926cfc97b3f7">OpenSim::AbstractProperty::getNumValues()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">OpenSim::AbstractProperty::setValueIsDefault()</a>.</p>

<p>Referenced by <a class="el" href="classOpenSim_1_1Property.html#aa9c23999672ed5ec0d74d140a67e89ea">OpenSim::Property&lt; T &gt;::operator=()</a>, and <a class="el" href="classOpenSim_1_1Property.html#aa92e55af5a211a210900438d858a481a">OpenSim::Property&lt; T &gt;::setValue()</a>.</p>

</div>
</div>
<a class="anchor" id="aa92e55af5a211a210900438d858a481a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::setValue </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provide a new value for a single-valued property. </p>
<p>The current value (if any) is replaced, and size()==1 afterwards. An exception is thrown if this is a list property. </p>

<p>References <a class="el" href="classOpenSim_1_1AbstractProperty.html#a5bd68b4e2e7ca1de8236f16ce71cda29">OpenSim::AbstractProperty::getName()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#ada2da76dbb28b3bd2d56dcbdbaf4aa5e">OpenSim::AbstractProperty::isListProperty()</a>, and <a class="el" href="classOpenSim_1_1Property.html#a3a8b68f9fa4cf67c5b9d681b4499d63e">OpenSim::Property&lt; T &gt;::setValue()</a>.</p>

</div>
</div>
<a class="anchor" id="a00355490194329012905b3407917fe9e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;template&lt; class &gt; class Container&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::setValue </td>
          <td>(</td>
          <td class="paramtype">const Container&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment to a container of values of type T sets the entire value list of this list property to a copy of the values in the container. </p>
<p>The current value is cleared before the assignment. </p>

<p>References <a class="el" href="classOpenSim_1_1AbstractProperty.html#a5ec8c00426c6841139be00515e749713">OpenSim::AbstractProperty::clear()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a6d7ad40bcb2da56c7c7ac6df61127a66">OpenSim::AbstractProperty::getMaxListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a08d92ed0f4c96fe7810276c5393dfd65">OpenSim::AbstractProperty::getMinListSize()</a>, <a class="el" href="classOpenSim_1_1AbstractProperty.html#a5bd68b4e2e7ca1de8236f16ce71cda29">OpenSim::AbstractProperty::getName()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">OpenSim::AbstractProperty::setValueIsDefault()</a>.</p>

</div>
</div>
<a class="anchor" id="ac416f4ac135fcadc1a35b47b3cd36f0b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classOpenSim_1_1Property.html">Property</a>&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::updAs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOpenSim_1_1AbstractProperty.html">AbstractProperty</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Downcast the given <a class="el" href="classOpenSim_1_1AbstractProperty.html" title="An abstract property is a serializable (name,value) pair, for which we do not know the type of the va...">AbstractProperty</a> to a writable concrete property of this type (Property&lt;T&gt;). </p>
<p>An exception is thrown if this is not the right type only in DEBUG mode; see <a class="el" href="classOpenSim_1_1Property.html#a7a234feb91cb9e416ceaaff20586b17b" title="Return true if the given AbstractProperty references a concrete property of this type (Property&lt;T&gt;)...">isA()</a> if you need to check first. </p>

<p>References <a class="el" href="classOpenSim_1_1AbstractProperty.html#a5bd68b4e2e7ca1de8236f16ce71cda29">OpenSim::AbstractProperty::getName()</a>, <a class="el" href="classOpenSim_1_1Property.html#aa9c23999672ed5ec0d74d140a67e89ea">OpenSim::Property&lt; T &gt;::operator=()</a>, <a class="el" href="classOpenSim_1_1Property.html#aa062d40d7e621c8891e2eefcd9cd6215">OpenSim::Property&lt; T &gt;::Property()</a>, and <a class="el" href="classOpenSim_1_1Property.html#a5d9596fe70f1c128d31a4034a27e175c">OpenSim::Property&lt; T &gt;::~Property()</a>.</p>

<p>Referenced by <a class="el" href="classOpenSim_1_1Property.html#aa7bc4edc7b1102885371bbeece620f43">OpenSim::Property&lt; T &gt;::getTypeName()</a>, and <a class="el" href="classOpenSim_1_1PropertyTable.html#aec71e379bcfc07db394c4ca6c300d2f4">OpenSim::PropertyTable::updProperty()</a>.</p>

</div>
</div>
<a class="anchor" id="ae597340fa1da9385439bbebf91a6a92a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classOpenSim_1_1Property.html">OpenSim::Property</a>&lt; T &gt;::updValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a writable reference to the selected value from this property's value list. </p>
<p>If the property is at most single valued then the <em>index</em> is optional and we'll behave as though index=0 were supplied. You can use the square bracket operator property[index] instead. </p>

<p>References <a class="el" href="classOpenSim_1_1AbstractProperty.html#a6d7ad40bcb2da56c7c7ac6df61127a66">OpenSim::AbstractProperty::getMaxListSize()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a10ec6fb0a5d6beaef87cf228b34d48cf">OpenSim::AbstractProperty::setValueIsDefault()</a>.</p>

<p>Referenced by <a class="el" href="classOpenSim_1_1Property.html#a567d26efb726367aca90f2534b032352">OpenSim::Property&lt; T &gt;::operator[]()</a>, and <a class="el" href="classOpenSim_1_1AbstractProperty.html#a08cd08421dc135dface6cb9fb3d1e1c1">OpenSim::AbstractProperty::updValue()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>OpenSim/Common/AbstractProperty.h</li>
<li>OpenSim/Common/Property.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceOpenSim.html">OpenSim</a></li><li class="navelem"><a class="el" href="classOpenSim_1_1Property.html">Property</a></li>
    <li class="footer">Generated on Thu Feb 6 2020 19:08:08 for API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
